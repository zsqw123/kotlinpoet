{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KotlinPoet \u00b6 KotlinPoet is a Kotlin and Java API for generating .kt source files. Source file generation can be useful when doing things such as annotation processing or interacting with metadata files (e.g., database schemas, protocol formats). By generating code, you eliminate the need to write boilerplate while also keeping a single source of truth for the metadata. Example \u00b6 Here\u2019s a HelloWorld file: class Greeter ( val name : String ) { fun greet () { println ( \"\"\"Hello, $ name \"\"\" ) } } fun main ( vararg args : String ) { Greeter ( args [ 0 ] ). greet () } And this is the code to generate it with KotlinPoet: val greeterClass = ClassName ( \"\" , \"Greeter\" ) val file = FileSpec . builder ( \"\" , \"HelloWorld\" ) . addType ( TypeSpec . classBuilder ( \"Greeter\" ) . primaryConstructor ( FunSpec . constructorBuilder () . addParameter ( \"name\" , String :: class ) . build () ) . addProperty ( PropertySpec . builder ( \"name\" , String :: class ) . initializer ( \"name\" ) . build () ) . addFunction ( FunSpec . builder ( \"greet\" ) . addStatement ( \"println(%P)\" , \"Hello, \\ $ name \" ) . build () ) . build () ) . addFunction ( FunSpec . builder ( \"main\" ) . addParameter ( \"args\" , String :: class , VARARG ) . addStatement ( \"%T(args[0]).greet()\" , greeterClass ) . build () ) . build () file . writeTo ( System . out ) The KDoc catalogs the complete KotlinPoet API, which is inspired by JavaPoet . Note: In order to maximize portability, KotlinPoet generates code with explicit visibility modifiers. This ensures compatibility with both standard Kotlin projects as well as projects using explicit API mode . Examples in this file omit those modifiers for brevity. Code & Control Flow \u00b6 Most of KotlinPoet\u2019s API uses immutable Kotlin objects. There\u2019s also builders, method chaining and varargs to make the API friendly. KotlinPoet offers models for Kotlin files ( FileSpec ), classes, interfaces & objects ( TypeSpec ), type aliases ( TypeAliasSpec ), properties ( PropertySpec ), functions & constructors ( FunSpec ), parameters ( ParameterSpec ) and annotations ( AnnotationSpec ). But the body of methods and constructors is not modeled. There\u2019s no expression class, no statement class or syntax tree nodes. Instead, KotlinPoet uses strings for code blocks, and you can take advantage of Kotlin\u2019s multiline strings to make this look nice: val main = FunSpec . builder ( \"main\" ) . addCode ( \"\"\" |var total = 0 |for (i in 0 until 10) { | total += i |} |\"\"\" . trimMargin ()) . build () Which generates this: fun main () { var total = 0 for ( i in 0 until 10 ) { total += i } } There are additional APIs to assist with newlines, braces and indentation: val main = FunSpec . builder ( \"main\" ) . addStatement ( \"var total = 0\" ) . beginControlFlow ( \"for (i in 0 until 10)\" ) . addStatement ( \"total += i\" ) . endControlFlow () . build () This example is lame because the generated code is constant! Suppose instead of just adding 0 to 10, we want to make the operation and range configurable. Here\u2019s a method that generates a method: private fun computeRange ( name : String , from : Int , to : Int , op : String ): FunSpec { return FunSpec . builder ( name ) . returns ( Int :: class ) . addStatement ( \"var result = 1\" ) . beginControlFlow ( \"for (i in $ from until $ to )\" ) . addStatement ( \"result = result $ op i\" ) . endControlFlow () . addStatement ( \"return result\" ) . build () } And here\u2019s what we get when we call computeRange(\"multiply10to20\", 10, 20, \"*\") : fun multiply10to20 (): kotlin . Int { var result = 1 for ( i in 10 until 20 ) { result = result * i } return result } Methods generating methods! And since KotlinPoet generates source instead of bytecode, you can read through it to make sure it\u2019s right. %S for Strings \u00b6 When emitting code that includes string literals, we can use %S to emit a string , complete with wrapping quotation marks and escaping. Here\u2019s a program that emits 3 methods, each of which returns its own name: fun main ( args : Array < String > ) { val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addFunction ( whatsMyNameYo ( \"slimShady\" )) . addFunction ( whatsMyNameYo ( \"eminem\" )) . addFunction ( whatsMyNameYo ( \"marshallMathers\" )) . build () val kotlinFile = FileSpec . builder ( \"com.example.helloworld\" , \"HelloWorld\" ) . addType ( helloWorld ) . build () kotlinFile . writeTo ( System . out ) } private fun whatsMyNameYo ( name : String ): FunSpec { return FunSpec . builder ( name ) . returns ( String :: class ) . addStatement ( \"return %S\" , name ) . build () } In this case, using %S gives us quotation marks: class HelloWorld { fun slimShady (): String = \"slimShady\" fun eminem (): String = \"eminem\" fun marshallMathers (): String = \"marshallMathers\" } %P for String Templates \u00b6 %S also handles the escaping of dollar signs ( $ ), to avoid inadvertent creation of string templates, which may fail to compile in generated code: val stringWithADollar = \"Your total is \" + \" $ \" + \"50\" val funSpec = FunSpec . builder ( \"printTotal\" ) . returns ( String :: class ) . addStatement ( \"return %S\" , stringWithADollar ) . build () produces: fun printTotal (): String = \"Your total is ${ '$' } 50\" If you need to generate string templates, use %P , which doesn\u2019t escape dollars: val amount = 50 val stringWithADollar = \"Your total is \" + \" $ \" + \"amount\" val funSpec = FunSpec . builder ( \"printTotal\" ) . returns ( String :: class ) . addStatement ( \"return %P\" , stringWithADollar ) . build () produces: fun printTotal (): String = \"Your total is $ amount \" You can also use CodeBlock s as arguments to %P , which is handy when you need to reference importable types or members inside the string template: val file = FileSpec . builder ( \"com.example\" , \"Digits\" ) . addFunction ( FunSpec . builder ( \"print\" ) . addParameter ( \"digits\" , IntArray :: class ) . addStatement ( \"println(%P)\" , buildCodeBlock { val contentToString = MemberName ( \"kotlin.collections\" , \"contentToString\" ) add ( \"These are the digits: \\ ${ digits . % M () } \" , contentToString ) }) . build () ) . build () println ( file ) The snippet above will produce the following output, handling the imports properly: package com.example import kotlin.IntArray import kotlin.collections.contentToString fun print ( digits : IntArray ) { println ( \"\"\"These are the digits: ${ digits . contentToString () } \"\"\" ) } %T for Types \u00b6 KotlinPoet has rich built-in support for types, including automatic generation of import statements. Just use %T to reference types : val today = FunSpec . builder ( \"today\" ) . returns ( Date :: class ) . addStatement ( \"return %T()\" , Date :: class ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addFunction ( today ) . build () val kotlinFile = FileSpec . builder ( \"com.example.helloworld\" , \"HelloWorld\" ) . addType ( helloWorld ) . build () kotlinFile . writeTo ( System . out ) That generates the following .kt file, complete with the necessary import : package com.example.helloworld import java.util.Date class HelloWorld { fun today (): Date = Date () } We passed Date::class to reference a class that just-so-happens to be available when we\u2019re generating code. This doesn\u2019t need to be the case. Here\u2019s a similar example, but this one references a class that doesn\u2019t exist (yet): val hoverboard = ClassName ( \"com.mattel\" , \"Hoverboard\" ) val tomorrow = FunSpec . builder ( \"tomorrow\" ) . returns ( hoverboard ) . addStatement ( \"return %T()\" , hoverboard ) . build () And that not-yet-existent class is imported as well: package com.example.helloworld import com.mattel.Hoverboard class HelloWorld { fun tomorrow (): Hoverboard = Hoverboard () } The ClassName type is very important, and you\u2019ll need it frequently when you\u2019re using KotlinPoet. It can identify any declared class. Declared types are just the beginning of Kotlin\u2019s rich type system: we also have arrays, parameterized types, wildcard types, lambda types and type variables. KotlinPoet has classes for building each of these: import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy val hoverboard = ClassName ( \"com.mattel\" , \"Hoverboard\" ) val list = ClassName ( \"kotlin.collections\" , \"List\" ) val arrayList = ClassName ( \"kotlin.collections\" , \"ArrayList\" ) val listOfHoverboards = list . parameterizedBy ( hoverboard ) val arrayListOfHoverboards = arrayList . parameterizedBy ( hoverboard ) val thing = ClassName ( \"com.misc\" , \"Thing\" ) val array = ClassName ( \"kotlin\" , \"Array\" ) val producerArrayOfThings = array . parameterizedBy ( WildcardTypeName . producerOf ( thing )) val beyond = FunSpec . builder ( \"beyond\" ) . returns ( listOfHoverboards ) . addStatement ( \"val result = %T()\" , arrayListOfHoverboards ) . addStatement ( \"result += %T()\" , hoverboard ) . addStatement ( \"result += %T()\" , hoverboard ) . addStatement ( \"result += %T()\" , hoverboard ) . addStatement ( \"return result\" ) . build () val printThings = FunSpec . builder ( \"printThings\" ) . addParameter ( \"things\" , producerArrayOfThings ) . addStatement ( \"println(things)\" ) . build () KotlinPoet will decompose each type and import its components where possible. package com.example.helloworld import com.mattel.Hoverboard import com.misc.Thing import kotlin.Array import kotlin.collections.ArrayList import kotlin.collections.List class HelloWorld { fun beyond (): List < Hoverboard > { val result = ArrayList < Hoverboard > () result += Hoverboard () result += Hoverboard () result += Hoverboard () return result } fun printThings ( things : Array < out Thing > ) { println ( things ) } } Nullable Types \u00b6 KotlinPoet supports nullable types. To convert a TypeName into its nullable counterpart, use the copy() method with nullable parameter set to true : val java = PropertySpec . builder ( \"java\" , String :: class . asTypeName (). copy ( nullable = true )) . mutable () . addModifiers ( KModifier . PRIVATE ) . initializer ( \"null\" ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addProperty ( java ) . addProperty ( \"kotlin\" , String :: class , KModifier . PRIVATE ) . build () generates: class HelloWorld { private var java : String? = null private val kotlin : String } %M for Members \u00b6 Similar to types, KotlinPoet has a special placeholder for members (functions and properties), which comes handy when your code needs to access top-level members and members declared inside objects. Use %M to reference members, pass an instance of MemberName as the argument for the placeholder, and KotlinPoet will handle imports automatically: val createTaco = MemberName ( \"com.squareup.tacos\" , \"createTaco\" ) val isVegan = MemberName ( \"com.squareup.tacos\" , \"isVegan\" ) val file = FileSpec . builder ( \"com.squareup.example\" , \"TacoTest\" ) . addFunction ( FunSpec . builder ( \"main\" ) . addStatement ( \"val taco = %M()\" , createTaco ) . addStatement ( \"println(taco.%M)\" , isVegan ) . build () ) . build () println ( file ) The code above generates the following file: package com.squareup.example import com.squareup.tacos.createTaco import com.squareup.tacos.isVegan fun main () { val taco = createTaco () println ( taco . isVegan ) } As you can see, it\u2019s also possible to use %M to reference extension functions and properties. You just need to make sure the member can be imported without simple name collisions, otherwise importing will fail and the code generator output will not pass compilation. There\u2019s a way to work around such cases though - use FileSpec.addAliasedImport() to create an alias for a clashing MemberName : val createTaco = MemberName ( \"com.squareup.tacos\" , \"createTaco\" ) val createCake = MemberName ( \"com.squareup.cakes\" , \"createCake\" ) val isTacoVegan = MemberName ( \"com.squareup.tacos\" , \"isVegan\" ) val isCakeVegan = MemberName ( \"com.squareup.cakes\" , \"isVegan\" ) val file = FileSpec . builder ( \"com.squareup.example\" , \"Test\" ) . addAliasedImport ( isTacoVegan , \"isTacoVegan\" ) . addAliasedImport ( isCakeVegan , \"isCakeVegan\" ) . addFunction ( FunSpec . builder ( \"main\" ) . addStatement ( \"val taco = %M()\" , createTaco ) . addStatement ( \"val cake = %M()\" , createCake ) . addStatement ( \"println(taco.%M)\" , isTacoVegan ) . addStatement ( \"println(cake.%M)\" , isCakeVegan ) . build () ) . build () println ( file ) KotlinPoet will produce an aliased import for com.squareup.tacos2.isVegan : package com.squareup.example import com.squareup.cakes.createCake import com.squareup.tacos.createTaco import com.squareup.cakes.isVegan as isCakeVegan import com.squareup.tacos.isVegan as isTacoVegan fun main () { val taco = createTaco () val cake = createCake () println ( taco . isTacoVegan ) println ( cake . isCakeVegan ) } MemberName and operators \u00b6 MemberName also supports operators, you can use MemberName(String, KOperator) or MemberName(ClassName, KOperator) to import and reference operators. val taco = ClassName ( \"com.squareup.tacos\" , \"Taco\" ) val meat = ClassName ( \"com.squareup.tacos.ingredient\" , \"Meat\" ) val iterator = MemberName ( \"com.squareup.tacos.internal\" , KOperator . ITERATOR ) val minusAssign = MemberName ( \"com.squareup.tacos.internal\" , KOperator . MINUS_ASSIGN ) val file = FileSpec . builder ( \"com.example\" , \"Test\" ) . addFunction ( FunSpec . builder ( \"makeTacoHealthy\" ) . addParameter ( \"taco\" , taco ) . beginControlFlow ( \"for (ingredient %M taco)\" , iterator ) . addStatement ( \"if (ingredient is %T) taco %M ingredient\" , meat , minusAssign ) . endControlFlow () . addStatement ( \"return taco\" ) . build () ) . build () println ( file ) KotlinPoet will import the extension operator functions and emit the operator. package com.example import com.squareup.tacos.Taco import com.squareup.tacos.ingredient.Meat import com.squareup.tacos.internal.iterator import com.squareup.tacos.internal.minusAssign fun makeTacoHealthy ( taco : Taco ) { for ( ingredient in taco ) { if ( ingredient is Meat ) taco -= ingredient } return taco } %N for Names \u00b6 Generated code is often self-referential. Use %N to refer to another generated declaration by its name. Here\u2019s a method that calls another: fun byteToHex ( b : Int ): String { val result = CharArray ( 2 ) result [ 0 ] = hexDigit (( b ushr 4 ) and 0 xf ) result [ 1 ] = hexDigit ( b and 0 xf ) return String ( result ) } fun hexDigit ( i : Int ): Char { return ( if ( i < 10 ) i + '0' . toInt () else i - 10 + 'a' . toInt ()). toChar () } When generating the code above, we pass the hexDigit() method as an argument to the byteToHex() method using %N : val hexDigit = FunSpec . builder ( \"hexDigit\" ) . addParameter ( \"i\" , Int :: class ) . returns ( Char :: class ) . addStatement ( \"return (if (i < 10) i + '0'.toInt() else i - 10 + 'a'.toInt()).toChar()\" ) . build () val byteToHex = FunSpec . builder ( \"byteToHex\" ) . addParameter ( \"b\" , Int :: class ) . returns ( String :: class ) . addStatement ( \"val result = CharArray(2)\" ) . addStatement ( \"result[0] = %N((b ushr 4) and 0xf)\" , hexDigit ) . addStatement ( \"result[1] = %N(b and 0xf)\" , hexDigit ) . addStatement ( \"return String(result)\" ) . build () Another handy feature that %N provides is automatically escaping names that contain illegal identifier characters with double ticks. Suppose your code creates a MemberName with a Kotlin keyword as the simple name: val taco = ClassName ( \"com.squareup.tacos\" , \"Taco\" ) val packager = ClassName ( \"com.squareup.tacos\" , \"TacoPackager\" ) val file = FileSpec . builder ( \"com.example\" , \"Test\" ) . addFunction ( FunSpec . builder ( \"packageTacos\" ) . addParameter ( \"tacos\" , LIST . parameterizedBy ( taco )) . addParameter ( \"packager\" , packager ) . addStatement ( \"packager.%N(tacos)\" , packager . member ( \"package\" )) . build () ) . build () %N will escape the name for you, ensuring that the output will pass compilation: package com.example import com.squareup.tacos.Taco import com.squareup.tacos.TacoPackager import kotlin.collections.List fun packageTacos ( tacos : List < Taco > , packager : TacoPackager ) { packager . `package` ( tacos ) } %L for Literals \u00b6 Although Kotlin\u2019s string templates usually work well in cases when you want to include literals into generated code, KotlinPoet offers additional syntax inspired-by but incompatible-with String.format() . It accepts %L to emit a literal value in the output. This works just like Formatter \u2018s %s : private fun computeRange ( name : String , from : Int , to : Int , op : String ): FunSpec { return FunSpec . builder ( name ) . returns ( Int :: class ) . addStatement ( \"var result = 0\" ) . beginControlFlow ( \"for (i in %L until %L)\" , from , to ) . addStatement ( \"result = result %L i\" , op ) . endControlFlow () . addStatement ( \"return result\" ) . build () } Literals are emitted directly to the output code with no escaping. Arguments for literals may be strings, primitives, and a few KotlinPoet types described below. Code block format strings \u00b6 Code blocks may specify the values for their placeholders in a few ways. Only one style may be used for each operation on a code block. Relative Arguments \u00b6 Pass an argument value for each placeholder in the format string to CodeBlock.add() . In each example, we generate code to say \u201cI ate 3 tacos\u201d CodeBlock . builder (). add ( \"I ate %L %L\" , 3 , \"tacos\" ) Positional Arguments \u00b6 Place an integer index (1-based) before the placeholder in the format string to specify which argument to use. CodeBlock . builder (). add ( \"I ate %2L %1L\" , \"tacos\" , 3 ) Named Arguments \u00b6 Use the syntax %argumentName:X where X is the format character and call CodeBlock.addNamed() with a map containing all argument keys in the format string. Argument names use characters in a-z , A-Z , 0-9 , and _ , and must start with a lowercase character. val map = LinkedHashMap < String , Any > () map += \"food\" to \"tacos\" map += \"count\" to 3 CodeBlock . builder (). addNamed ( \"I ate %count:L %food:L\" , map ) Functions \u00b6 All of the above functions have a code body. Use KModifier.ABSTRACT to get a function without any body. This is only legal if it is enclosed by an abstract class or an interface. val flux = FunSpec . builder ( \"flux\" ) . addModifiers ( KModifier . ABSTRACT , KModifier . PROTECTED ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addModifiers ( KModifier . ABSTRACT ) . addFunction ( flux ) . build () Which generates this: abstract class HelloWorld { protected abstract fun flux () } The other modifiers work where permitted. Methods also have parameters, varargs, KDoc, annotations, type variables, return type and receiver type for extension functions. All of these are configured with FunSpec.Builder . Extension functions \u00b6 Extension functions can be generated by specifying a receiver . val square = FunSpec . builder ( \"square\" ) . receiver ( Int :: class ) . returns ( Int :: class ) . addStatement ( \"var s = this * this\" ) . addStatement ( \"return s\" ) . build () Which outputs: fun Int . square (): Int { val s = this * this return s } Single-expression functions \u00b6 KotlinPoet can recognize single-expression functions and print them out properly. It treats each function with a body that starts with return as a single-expression function: val abs = FunSpec . builder ( \"abs\" ) . addParameter ( \"x\" , Int :: class ) . returns ( Int :: class ) . addStatement ( \"return if (x < 0) -x else x\" ) . build () Which outputs: fun abs ( x : Int ): Int = if ( x < 0 ) - x else x Default function arguments \u00b6 Consider the example below. Function argument b has a default value of 0 to avoid overloading this function. fun add ( a : Int , b : Int = 0 ) { print ( \"a + b = ${ a + b } \" ) } Use the defaultValue() builder function to declare default value for a function argument. FunSpec . builder ( \"add\" ) . addParameter ( \"a\" , Int :: class ) . addParameter ( ParameterSpec . builder ( \"b\" , Int :: class ) . defaultValue ( \"%L\" , 0 ) . build () ) . addStatement ( \"print(\\\"a + b = ${ a + b } \\\")\" ) . build () Spaces wrap by default! \u00b6 In order to provide meaningful formatting, KotlinPoet would replace spaces, found in blocks of code, with new line symbols, in cases when the line of code exceeds the length limit. Let\u2019s take this function for example: val funSpec = FunSpec . builder ( \"foo\" ) . addStatement ( \"return (100..10000).map { number -> number * number }.map { number -> number.toString() }.also { string -> println(string) }\" ) . build () Depending on where it\u2019s found in the file, it may end up being printed out like this: fun foo () = ( 100. . 10000 ). map { number -> number * number }. map { number -> number . toString () }. also { string -> println ( string ) } Unfortunately this code is broken: the compiler expects also and { to be on the same line. KotlinPoet is unable to understand the context of the expression and fix the formatting for you, but there\u2019s a trick you can use to declare a non-breaking space - use the \u00b7 symbol where you would otherwise use a space. Let\u2019s apply this to our example: val funSpec = FunSpec . builder ( \"foo\" ) . addStatement ( \"return (100..10000).map\u00b7{ number -> number * number }.map\u00b7{ number -> number.toString() }.also\u00b7{ string -> println(string) }\" ) . build () This will now produce the following result: fun foo () = ( 100. . 10000 ). map { number -> number * number }. map { number -> number . toString () }. also { string -> println ( string ) } The code is now correct and will compile properly. It still doesn\u2019t look perfect - you can play with replacing other spaces in the code block with \u00b7 symbols to achieve better formatting. Constructors \u00b6 FunSpec is a slight misnomer; it can also be used for constructors: val flux = FunSpec . constructorBuilder () . addParameter ( \"greeting\" , String :: class ) . addStatement ( \"this.%N = %N\" , \"greeting\" , \"greeting\" ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addProperty ( \"greeting\" , String :: class , KModifier . PRIVATE ) . addFunction ( flux ) . build () Which generates this: class HelloWorld { private val greeting : String constructor ( greeting : String ) { this . greeting = greeting } } For the most part, constructors work just like methods. When emitting code, KotlinPoet will place constructors before methods in the output file. Often times you\u2019ll need to generate the primary constructor for a class: val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . primaryConstructor ( flux ) . addProperty ( \"greeting\" , String :: class , KModifier . PRIVATE ) . build () This code, however, generates the following: class HelloWorld ( greeting : String ) { private val greeting : String init { this . greeting = greeting } } By default, KotlinPoet won\u2019t merge primary constructor parameters and properties, even if they share the same name. To achieve the effect, you have to tell KotlinPoet that the property is initialized via the constructor parameter: val flux = FunSpec . constructorBuilder () . addParameter ( \"greeting\" , String :: class ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . primaryConstructor ( flux ) . addProperty ( PropertySpec . builder ( \"greeting\" , String :: class ) . initializer ( \"greeting\" ) . addModifiers ( KModifier . PRIVATE ) . build () ) . build () Now we\u2019re getting the following output: class HelloWorld ( private val greeting : String ) Notice that KotlinPoet omits {} for classes with empty bodies. Parameters \u00b6 Declare parameters on methods and constructors with either ParameterSpec.builder() or FunSpec \u2018s convenient addParameter() API: val android = ParameterSpec . builder ( \"android\" , String :: class ) . defaultValue ( \"\\\"pie\\\"\" ) . build () val welcomeOverlords = FunSpec . builder ( \"welcomeOverlords\" ) . addParameter ( android ) . addParameter ( \"robot\" , String :: class ) . build () The code above generates: fun welcomeOverlords ( android : String = \"pie\" , robot : String ) { } The extended Builder form is necessary when the parameter has annotations (such as @Inject ). Properties \u00b6 Like parameters, properties can be created either with builders or by using convenient helper methods: val android = PropertySpec . builder ( \"android\" , String :: class ) . addModifiers ( KModifier . PRIVATE ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addProperty ( android ) . addProperty ( \"robot\" , String :: class , KModifier . PRIVATE ) . build () Which generates: class HelloWorld { private val android : String private val robot : String } The extended Builder form is necessary when a field has KDoc, annotations, or a field initializer. Field initializers use the same String.format() -like syntax as the code blocks above: val android = PropertySpec . builder ( \"android\" , String :: class ) . addModifiers ( KModifier . PRIVATE ) . initializer ( \"%S + %L\" , \"Oreo v.\" , 8.1 ) . build () Which generates: private val android : String = \"Oreo v.\" + 8.1 By default PropertySpec.Builder produces val properties. Use mutable() if you need a var : val android = PropertySpec . builder ( \"android\" , String :: class ) . mutable () . addModifiers ( KModifier . PRIVATE ) . initializer ( \"%S + %L\" , \"Oreo v.\" , 8.1 ) . build () Inline properties \u00b6 The way KotlinPoet models inline properties deserves special mention. The following snippet of code: val android = PropertySpec . builder ( \"android\" , String :: class ) . mutable () . addModifiers ( KModifier . INLINE ) . build () will produce an error: java.lang.IllegalArgumentException: KotlinPoet doesn't allow setting the inline modifier on properties. You should mark either the getter, the setter, or both inline. Indeed, a property marked with inline should have at least one accessor which will be inlined by the compiler. Let\u2019s add a getter to this property: val android = PropertySpec . builder ( \"android\" , String :: class ) . mutable () . getter ( FunSpec . getterBuilder () . addModifiers ( KModifier . INLINE ) . addStatement ( \"return %S\" , \"foo\" ) . build () ) . build () The result is the following: var android : kotlin . String inline get () = \"foo\" Now, what if we wanted to add a non-inline setter to the property above? We can do so without modifying any of the code we wrote previously: val android = PropertySpec . builder ( \"android\" , String :: class ) . mutable () . getter ( FunSpec . getterBuilder () . addModifiers ( KModifier . INLINE ) . addStatement ( \"return %S\" , \"foo\" ) . build () ) . setter ( FunSpec . setterBuilder () . addParameter ( \"value\" , String :: class ) . build () ) . build () We get the expected result: var android : kotlin . String inline get () = \"foo\" set ( `value` ) { } Finally, if we go back and add KModifier.INLINE to the setter, KotlinPoet can wrap it nicely and produce the following result: inline var android : kotlin . String get () = \"foo\" set ( `value` ) { } Removing the modifier from either the getter or the setter will unwrap the expression back. If, on the other hand, KotlinPoet had allowed marking a property inline directly, the programmer would have had to manually add/remove the modifier whenever the state of the accessors changes in order to get correct and compilable output. We\u2019re solving this problem by making accessors the source of truth for the inline modifier. Interfaces \u00b6 KotlinPoet has no trouble with interfaces. Note that interface methods must always be ABSTRACT . The modifier is necessary when defining the interface: val helloWorld = TypeSpec . interfaceBuilder ( \"HelloWorld\" ) . addProperty ( \"buzz\" , String :: class ) . addFunction ( FunSpec . builder ( \"beep\" ) . addModifiers ( KModifier . ABSTRACT ) . build () ) . build () But these modifiers are omitted when the code is generated. These are the default so we don\u2019t need to include them for kotlinc \u2018s benefit! interface HelloWorld { val buzz : String fun beep () } Kotlin 1.4 adds support for functional interfaces via fun interface syntax. To create this in KotlinPoet, use TypeSpec.funInterfaceBuilder() . val helloWorld = TypeSpec . funInterfaceBuilder ( \"HelloWorld\" ) . addFunction ( FunSpec . builder ( \"beep\" ) . addModifiers ( KModifier . ABSTRACT ) . build () ) . build () // Generates... fun interface HelloWorld { fun beep () } Objects \u00b6 KotlinPoet supports objects: val helloWorld = TypeSpec . objectBuilder ( \"HelloWorld\" ) . addProperty ( PropertySpec . builder ( \"buzz\" , String :: class ) . initializer ( \"%S\" , \"buzz\" ) . build () ) . addFunction ( FunSpec . builder ( \"beep\" ) . addStatement ( \"println(%S)\" , \"Beep!\" ) . build () ) . build () Similarly, you can create companion objects and add them to classes using addType() : val companion = TypeSpec . companionObjectBuilder () . addProperty ( PropertySpec . builder ( \"buzz\" , String :: class ) . initializer ( \"%S\" , \"buzz\" ) . build () ) . addFunction ( FunSpec . builder ( \"beep\" ) . addStatement ( \"println(%S)\" , \"Beep!\" ) . build () ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addType ( companion ) . build () You can provide an optional name for a companion object. Enums \u00b6 Use enumBuilder to create the enum type, and addEnumConstant() for each value: val helloWorld = TypeSpec . enumBuilder ( \"Roshambo\" ) . addEnumConstant ( \"ROCK\" ) . addEnumConstant ( \"SCISSORS\" ) . addEnumConstant ( \"PAPER\" ) . build () To generate this: enum class Roshambo { ROCK , SCISSORS , PAPER } Fancy enums are supported, where the enum values override methods or call a superclass constructor. Here\u2019s a comprehensive example: val helloWorld = TypeSpec . enumBuilder ( \"Roshambo\" ) . primaryConstructor ( FunSpec . constructorBuilder () . addParameter ( \"handsign\" , String :: class ) . build () ) . addEnumConstant ( \"ROCK\" , TypeSpec . anonymousClassBuilder () . addSuperclassConstructorParameter ( \"%S\" , \"fist\" ) . addFunction ( FunSpec . builder ( \"toString\" ) . addModifiers ( KModifier . OVERRIDE ) . addStatement ( \"return %S\" , \"avalanche!\" ) . returns ( String :: class ) . build () ) . build () ) . addEnumConstant ( \"SCISSORS\" , TypeSpec . anonymousClassBuilder () . addSuperclassConstructorParameter ( \"%S\" , \"peace\" ) . build () ) . addEnumConstant ( \"PAPER\" , TypeSpec . anonymousClassBuilder () . addSuperclassConstructorParameter ( \"%S\" , \"flat\" ) . build () ) . addProperty ( PropertySpec . builder ( \"handsign\" , String :: class , KModifier . PRIVATE ) . initializer ( \"handsign\" ) . build () ) . build () Which generates this: enum class Roshambo ( private val handsign : String ) { ROCK ( \"fist\" ) { override fun toString (): String = \"avalanche!\" }, SCISSORS ( \"peace\" ), PAPER ( \"flat\" ); } Anonymous Inner Classes \u00b6 In the enum code, we used TypeSpec.anonymousClassBuilder() . Anonymous inner classes can also be used in code blocks. They are values that can be referenced with %L : val comparator = TypeSpec . anonymousClassBuilder () . addSuperinterface ( Comparator :: class . parameterizedBy ( String :: class )) . addFunction ( FunSpec . builder ( \"compare\" ) . addModifiers ( KModifier . OVERRIDE ) . addParameter ( \"a\" , String :: class ) . addParameter ( \"b\" , String :: class ) . returns ( Int :: class ) . addStatement ( \"return %N.length - %N.length\" , \"a\" , \"b\" ) . build () ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addFunction ( FunSpec . builder ( \"sortByLength\" ) . addParameter ( \"strings\" , List :: class . parameterizedBy ( String :: class )) . addStatement ( \"%N.sortedWith(%L)\" , \"strings\" , comparator ) . build () ) . build () This generates a method that contains a class that contains a method: class HelloWorld { fun sortByLength ( strings : List < String > ) { strings . sortedWith ( object : Comparator < String > { override fun compare ( a : String , b : String ): Int = a . length - b . length }) } } One particularly tricky part of defining anonymous inner classes is the arguments to the superclass constructor. To pass them use TypeSpec.Builder \u2018s addSuperclassConstructorParameter() method. Annotations \u00b6 Simple annotations are easy: val test = FunSpec . builder ( \"test string equality\" ) . addAnnotation ( Test :: class ) . addStatement ( \"assertThat(%1S).isEqualTo(%1S)\" , \"foo\" ) . build () Which generates this function with an @Test annotation: @Test fun `test string equality` () { assertThat ( \"foo\" ). isEqualTo ( \"foo\" ) } Use AnnotationSpec.builder() to set properties on annotations: val logRecord = FunSpec . builder ( \"recordEvent\" ) . addModifiers ( KModifier . ABSTRACT ) . addAnnotation ( AnnotationSpec . builder ( Headers :: class ) . addMember ( \"accept = %S\" , \"application/json; charset=utf-8\" ) . addMember ( \"userAgent = %S\" , \"Square Cash\" ) . build () ) . addParameter ( \"logRecord\" , LogRecord :: class ) . returns ( LogReceipt :: class ) . build () Which generates this annotation with accept and userAgent properties: @Headers ( accept = \"application/json; charset=utf-8\" , userAgent = \"Square Cash\" ) abstract fun recordEvent ( logRecord : LogRecord ): LogReceipt When you get fancy, annotation values can be annotations themselves. Use %L for embedded annotations: val headerList = ClassName ( \"\" , \"HeaderList\" ) val header = ClassName ( \"\" , \"Header\" ) val logRecord = FunSpec . builder ( \"recordEvent\" ) . addModifiers ( KModifier . ABSTRACT ) . addAnnotation ( AnnotationSpec . builder ( headerList ) . addMember ( \"[\\n\u21e5%L,\\n%L\u21e4\\n]\" , AnnotationSpec . builder ( header ) . addMember ( \"name = %S\" , \"Accept\" ) . addMember ( \"value = %S\" , \"application/json; charset=utf-8\" ) . build (), AnnotationSpec . builder ( header ) . addMember ( \"name = %S\" , \"User-Agent\" ) . addMember ( \"value = %S\" , \"Square Cash\" ) . build () ) . build () ) . addParameter ( \"logRecord\" , logRecordName ) . returns ( logReceipt ) . build () Which generates this: @HeaderList ( [ Header ( name = \"Accept\" , value = \"application/json; charset=utf-8\" ), Header ( name = \"User-Agent\" , value = \"Square Cash\" ) ] ) abstract fun recordEvent ( logRecord : LogRecord ): LogReceipt KotlinPoet supports use-site targets for annotations: val utils = FileSpec . builder ( \"com.example\" , \"Utils\" ) . addAnnotation ( AnnotationSpec . builder ( JvmName :: class ) . useSiteTarget ( UseSiteTarget . FILE ) . build () ) . addFunction ( FunSpec . builder ( \"abs\" ) . receiver ( Int :: class ) . returns ( Int :: class ) . addStatement ( \"return if (this < 0) -this else this\" ) . build () ) . build () Will output this: @file : JvmName package com.example import kotlin.Int import kotlin.jvm.JvmName fun Int . abs (): Int = if ( this < 0 ) - this else this Type Aliases \u00b6 KotlinPoet provides API for creating Type Aliases, which supports simple class names, parameterized types and lambdas: val k = TypeVariableName ( \"K\" ) val t = TypeVariableName ( \"T\" ) val fileTable = Map :: class . asClassName () . parameterizedBy ( k , Set :: class . parameterizedBy ( File :: class )) val predicate = LambdaTypeName . get ( parameters = arrayOf ( t ), returnType = Boolean :: class . asClassName () ) val helloWorld = FileSpec . builder ( \"com.example\" , \"HelloWorld\" ) . addTypeAlias ( TypeAliasSpec . builder ( \"Word\" , String :: class ). build ()) . addTypeAlias ( TypeAliasSpec . builder ( \"FileTable\" , fileTable ) . addTypeVariable ( k ) . build () ) . addTypeAlias ( TypeAliasSpec . builder ( \"Predicate\" , predicate ) . addTypeVariable ( t ) . build () ) . build () Which generates the following: package com.example import java.io.File import kotlin.Boolean import kotlin.String import kotlin.collections.Map import kotlin.collections.Set typealias Word = String typealias FileTable < K > = Map < K , Set < File >> typealias Predicate < T > = ( T ) -> Boolean Callable References \u00b6 Callable references to constructors, functions, and properties may be emitted via: ClassName.constructorReference() for constructors MemberName.reference() for functions and properties For example, val helloClass = ClassName ( \"com.example.hello\" , \"Hello\" ) val worldFunction : MemberName = helloClass . member ( \"world\" ) val byeProperty : MemberName = helloClass . nestedClass ( \"World\" ). member ( \"bye\" ) val factoriesFun = FunSpec . builder ( \"factories\" ) . addStatement ( \"val hello = %L\" , helloClass . constructorReference ()) . addStatement ( \"val world = %L\" , worldFunction . reference ()) . addStatement ( \"val bye = %L\" , byeProperty . reference ()) . build () FileSpec . builder ( \"com.example\" , \"HelloWorld\" ) . addFunction ( factoriesFun ) . build () would generate: package com.example import com.example.hello.Hello fun factories () { val hello = :: Hello val world = Hello :: world val bye = Hello . World :: bye } Top-level classes and members with conflicting names may require aliased imports, as with member names . kotlin-reflect \u00b6 To generate source code from any KType , including information that\u2019s not accessible to the builtin reflection APIs, KotlinPoet depends on kotlin-reflect . kotlin-reflect can read the metadata of your classes and access this extra information. KotlinPoet can for an example, read the type parameters and their variance from a generic KType and generate appropriate source code. kotlin-reflect is a relatively big dependency though and in some cases it is desirable to remove it from the final executable to save some space and/or simplify the proguard/R8 setup (for example for a Gradle plugin that generates Kotlin code). It is possible to do so and still use most of the KotlinPoet APIs: dependencies { implementation ( \"com.squareup:kotlinpoet:<version>\" ) { exclude ( module = \"kotlin-reflect\" ) } } The main APIs that require kotlin-reflect are KType.asTypeName() and typeNameOf<T>() . If you\u2019re calling one of these without kotlin-reflect in the classpath and the type is generic or has annotations you will get a crash. You can replace it with code that passes type parameters or annotations explicitly and doesn\u2019t need kotlin-reflect . For example: // Replace // kotlin-reflect needed val typeName = typeNameOf < List < Int? >> () // With // kotlin-reflect not needed val typeName = List :: class . asClassName (). parameterizedBy ( Int :: class . asClassName (). copy ( nullable = true )) Download \u00b6 Download the latest .jar or depend via Maven: <dependency> <groupId> com.squareup </groupId> <artifactId> kotlinpoet </artifactId> <version> 1.11.0 </version> </dependency> or Gradle: implementation ( \"com.squareup:kotlinpoet:1.11.0\" ) Snapshots of the development version are available in Sonatype\u2019s snapshots repository . License \u00b6 Copyright 2017 Square, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"KotlinPoet"},{"location":"#kotlinpoet","text":"KotlinPoet is a Kotlin and Java API for generating .kt source files. Source file generation can be useful when doing things such as annotation processing or interacting with metadata files (e.g., database schemas, protocol formats). By generating code, you eliminate the need to write boilerplate while also keeping a single source of truth for the metadata.","title":"KotlinPoet"},{"location":"#example","text":"Here\u2019s a HelloWorld file: class Greeter ( val name : String ) { fun greet () { println ( \"\"\"Hello, $ name \"\"\" ) } } fun main ( vararg args : String ) { Greeter ( args [ 0 ] ). greet () } And this is the code to generate it with KotlinPoet: val greeterClass = ClassName ( \"\" , \"Greeter\" ) val file = FileSpec . builder ( \"\" , \"HelloWorld\" ) . addType ( TypeSpec . classBuilder ( \"Greeter\" ) . primaryConstructor ( FunSpec . constructorBuilder () . addParameter ( \"name\" , String :: class ) . build () ) . addProperty ( PropertySpec . builder ( \"name\" , String :: class ) . initializer ( \"name\" ) . build () ) . addFunction ( FunSpec . builder ( \"greet\" ) . addStatement ( \"println(%P)\" , \"Hello, \\ $ name \" ) . build () ) . build () ) . addFunction ( FunSpec . builder ( \"main\" ) . addParameter ( \"args\" , String :: class , VARARG ) . addStatement ( \"%T(args[0]).greet()\" , greeterClass ) . build () ) . build () file . writeTo ( System . out ) The KDoc catalogs the complete KotlinPoet API, which is inspired by JavaPoet . Note: In order to maximize portability, KotlinPoet generates code with explicit visibility modifiers. This ensures compatibility with both standard Kotlin projects as well as projects using explicit API mode . Examples in this file omit those modifiers for brevity.","title":"Example"},{"location":"#code-control-flow","text":"Most of KotlinPoet\u2019s API uses immutable Kotlin objects. There\u2019s also builders, method chaining and varargs to make the API friendly. KotlinPoet offers models for Kotlin files ( FileSpec ), classes, interfaces & objects ( TypeSpec ), type aliases ( TypeAliasSpec ), properties ( PropertySpec ), functions & constructors ( FunSpec ), parameters ( ParameterSpec ) and annotations ( AnnotationSpec ). But the body of methods and constructors is not modeled. There\u2019s no expression class, no statement class or syntax tree nodes. Instead, KotlinPoet uses strings for code blocks, and you can take advantage of Kotlin\u2019s multiline strings to make this look nice: val main = FunSpec . builder ( \"main\" ) . addCode ( \"\"\" |var total = 0 |for (i in 0 until 10) { | total += i |} |\"\"\" . trimMargin ()) . build () Which generates this: fun main () { var total = 0 for ( i in 0 until 10 ) { total += i } } There are additional APIs to assist with newlines, braces and indentation: val main = FunSpec . builder ( \"main\" ) . addStatement ( \"var total = 0\" ) . beginControlFlow ( \"for (i in 0 until 10)\" ) . addStatement ( \"total += i\" ) . endControlFlow () . build () This example is lame because the generated code is constant! Suppose instead of just adding 0 to 10, we want to make the operation and range configurable. Here\u2019s a method that generates a method: private fun computeRange ( name : String , from : Int , to : Int , op : String ): FunSpec { return FunSpec . builder ( name ) . returns ( Int :: class ) . addStatement ( \"var result = 1\" ) . beginControlFlow ( \"for (i in $ from until $ to )\" ) . addStatement ( \"result = result $ op i\" ) . endControlFlow () . addStatement ( \"return result\" ) . build () } And here\u2019s what we get when we call computeRange(\"multiply10to20\", 10, 20, \"*\") : fun multiply10to20 (): kotlin . Int { var result = 1 for ( i in 10 until 20 ) { result = result * i } return result } Methods generating methods! And since KotlinPoet generates source instead of bytecode, you can read through it to make sure it\u2019s right.","title":"Code &amp; Control Flow"},{"location":"#s-for-strings","text":"When emitting code that includes string literals, we can use %S to emit a string , complete with wrapping quotation marks and escaping. Here\u2019s a program that emits 3 methods, each of which returns its own name: fun main ( args : Array < String > ) { val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addFunction ( whatsMyNameYo ( \"slimShady\" )) . addFunction ( whatsMyNameYo ( \"eminem\" )) . addFunction ( whatsMyNameYo ( \"marshallMathers\" )) . build () val kotlinFile = FileSpec . builder ( \"com.example.helloworld\" , \"HelloWorld\" ) . addType ( helloWorld ) . build () kotlinFile . writeTo ( System . out ) } private fun whatsMyNameYo ( name : String ): FunSpec { return FunSpec . builder ( name ) . returns ( String :: class ) . addStatement ( \"return %S\" , name ) . build () } In this case, using %S gives us quotation marks: class HelloWorld { fun slimShady (): String = \"slimShady\" fun eminem (): String = \"eminem\" fun marshallMathers (): String = \"marshallMathers\" }","title":"%S for Strings"},{"location":"#p-for-string-templates","text":"%S also handles the escaping of dollar signs ( $ ), to avoid inadvertent creation of string templates, which may fail to compile in generated code: val stringWithADollar = \"Your total is \" + \" $ \" + \"50\" val funSpec = FunSpec . builder ( \"printTotal\" ) . returns ( String :: class ) . addStatement ( \"return %S\" , stringWithADollar ) . build () produces: fun printTotal (): String = \"Your total is ${ '$' } 50\" If you need to generate string templates, use %P , which doesn\u2019t escape dollars: val amount = 50 val stringWithADollar = \"Your total is \" + \" $ \" + \"amount\" val funSpec = FunSpec . builder ( \"printTotal\" ) . returns ( String :: class ) . addStatement ( \"return %P\" , stringWithADollar ) . build () produces: fun printTotal (): String = \"Your total is $ amount \" You can also use CodeBlock s as arguments to %P , which is handy when you need to reference importable types or members inside the string template: val file = FileSpec . builder ( \"com.example\" , \"Digits\" ) . addFunction ( FunSpec . builder ( \"print\" ) . addParameter ( \"digits\" , IntArray :: class ) . addStatement ( \"println(%P)\" , buildCodeBlock { val contentToString = MemberName ( \"kotlin.collections\" , \"contentToString\" ) add ( \"These are the digits: \\ ${ digits . % M () } \" , contentToString ) }) . build () ) . build () println ( file ) The snippet above will produce the following output, handling the imports properly: package com.example import kotlin.IntArray import kotlin.collections.contentToString fun print ( digits : IntArray ) { println ( \"\"\"These are the digits: ${ digits . contentToString () } \"\"\" ) }","title":"%P for String Templates"},{"location":"#t-for-types","text":"KotlinPoet has rich built-in support for types, including automatic generation of import statements. Just use %T to reference types : val today = FunSpec . builder ( \"today\" ) . returns ( Date :: class ) . addStatement ( \"return %T()\" , Date :: class ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addFunction ( today ) . build () val kotlinFile = FileSpec . builder ( \"com.example.helloworld\" , \"HelloWorld\" ) . addType ( helloWorld ) . build () kotlinFile . writeTo ( System . out ) That generates the following .kt file, complete with the necessary import : package com.example.helloworld import java.util.Date class HelloWorld { fun today (): Date = Date () } We passed Date::class to reference a class that just-so-happens to be available when we\u2019re generating code. This doesn\u2019t need to be the case. Here\u2019s a similar example, but this one references a class that doesn\u2019t exist (yet): val hoverboard = ClassName ( \"com.mattel\" , \"Hoverboard\" ) val tomorrow = FunSpec . builder ( \"tomorrow\" ) . returns ( hoverboard ) . addStatement ( \"return %T()\" , hoverboard ) . build () And that not-yet-existent class is imported as well: package com.example.helloworld import com.mattel.Hoverboard class HelloWorld { fun tomorrow (): Hoverboard = Hoverboard () } The ClassName type is very important, and you\u2019ll need it frequently when you\u2019re using KotlinPoet. It can identify any declared class. Declared types are just the beginning of Kotlin\u2019s rich type system: we also have arrays, parameterized types, wildcard types, lambda types and type variables. KotlinPoet has classes for building each of these: import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy val hoverboard = ClassName ( \"com.mattel\" , \"Hoverboard\" ) val list = ClassName ( \"kotlin.collections\" , \"List\" ) val arrayList = ClassName ( \"kotlin.collections\" , \"ArrayList\" ) val listOfHoverboards = list . parameterizedBy ( hoverboard ) val arrayListOfHoverboards = arrayList . parameterizedBy ( hoverboard ) val thing = ClassName ( \"com.misc\" , \"Thing\" ) val array = ClassName ( \"kotlin\" , \"Array\" ) val producerArrayOfThings = array . parameterizedBy ( WildcardTypeName . producerOf ( thing )) val beyond = FunSpec . builder ( \"beyond\" ) . returns ( listOfHoverboards ) . addStatement ( \"val result = %T()\" , arrayListOfHoverboards ) . addStatement ( \"result += %T()\" , hoverboard ) . addStatement ( \"result += %T()\" , hoverboard ) . addStatement ( \"result += %T()\" , hoverboard ) . addStatement ( \"return result\" ) . build () val printThings = FunSpec . builder ( \"printThings\" ) . addParameter ( \"things\" , producerArrayOfThings ) . addStatement ( \"println(things)\" ) . build () KotlinPoet will decompose each type and import its components where possible. package com.example.helloworld import com.mattel.Hoverboard import com.misc.Thing import kotlin.Array import kotlin.collections.ArrayList import kotlin.collections.List class HelloWorld { fun beyond (): List < Hoverboard > { val result = ArrayList < Hoverboard > () result += Hoverboard () result += Hoverboard () result += Hoverboard () return result } fun printThings ( things : Array < out Thing > ) { println ( things ) } }","title":"%T for Types"},{"location":"#nullable-types","text":"KotlinPoet supports nullable types. To convert a TypeName into its nullable counterpart, use the copy() method with nullable parameter set to true : val java = PropertySpec . builder ( \"java\" , String :: class . asTypeName (). copy ( nullable = true )) . mutable () . addModifiers ( KModifier . PRIVATE ) . initializer ( \"null\" ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addProperty ( java ) . addProperty ( \"kotlin\" , String :: class , KModifier . PRIVATE ) . build () generates: class HelloWorld { private var java : String? = null private val kotlin : String }","title":"Nullable Types"},{"location":"#m-for-members","text":"Similar to types, KotlinPoet has a special placeholder for members (functions and properties), which comes handy when your code needs to access top-level members and members declared inside objects. Use %M to reference members, pass an instance of MemberName as the argument for the placeholder, and KotlinPoet will handle imports automatically: val createTaco = MemberName ( \"com.squareup.tacos\" , \"createTaco\" ) val isVegan = MemberName ( \"com.squareup.tacos\" , \"isVegan\" ) val file = FileSpec . builder ( \"com.squareup.example\" , \"TacoTest\" ) . addFunction ( FunSpec . builder ( \"main\" ) . addStatement ( \"val taco = %M()\" , createTaco ) . addStatement ( \"println(taco.%M)\" , isVegan ) . build () ) . build () println ( file ) The code above generates the following file: package com.squareup.example import com.squareup.tacos.createTaco import com.squareup.tacos.isVegan fun main () { val taco = createTaco () println ( taco . isVegan ) } As you can see, it\u2019s also possible to use %M to reference extension functions and properties. You just need to make sure the member can be imported without simple name collisions, otherwise importing will fail and the code generator output will not pass compilation. There\u2019s a way to work around such cases though - use FileSpec.addAliasedImport() to create an alias for a clashing MemberName : val createTaco = MemberName ( \"com.squareup.tacos\" , \"createTaco\" ) val createCake = MemberName ( \"com.squareup.cakes\" , \"createCake\" ) val isTacoVegan = MemberName ( \"com.squareup.tacos\" , \"isVegan\" ) val isCakeVegan = MemberName ( \"com.squareup.cakes\" , \"isVegan\" ) val file = FileSpec . builder ( \"com.squareup.example\" , \"Test\" ) . addAliasedImport ( isTacoVegan , \"isTacoVegan\" ) . addAliasedImport ( isCakeVegan , \"isCakeVegan\" ) . addFunction ( FunSpec . builder ( \"main\" ) . addStatement ( \"val taco = %M()\" , createTaco ) . addStatement ( \"val cake = %M()\" , createCake ) . addStatement ( \"println(taco.%M)\" , isTacoVegan ) . addStatement ( \"println(cake.%M)\" , isCakeVegan ) . build () ) . build () println ( file ) KotlinPoet will produce an aliased import for com.squareup.tacos2.isVegan : package com.squareup.example import com.squareup.cakes.createCake import com.squareup.tacos.createTaco import com.squareup.cakes.isVegan as isCakeVegan import com.squareup.tacos.isVegan as isTacoVegan fun main () { val taco = createTaco () val cake = createCake () println ( taco . isTacoVegan ) println ( cake . isCakeVegan ) }","title":"%M for Members"},{"location":"#membername-and-operators","text":"MemberName also supports operators, you can use MemberName(String, KOperator) or MemberName(ClassName, KOperator) to import and reference operators. val taco = ClassName ( \"com.squareup.tacos\" , \"Taco\" ) val meat = ClassName ( \"com.squareup.tacos.ingredient\" , \"Meat\" ) val iterator = MemberName ( \"com.squareup.tacos.internal\" , KOperator . ITERATOR ) val minusAssign = MemberName ( \"com.squareup.tacos.internal\" , KOperator . MINUS_ASSIGN ) val file = FileSpec . builder ( \"com.example\" , \"Test\" ) . addFunction ( FunSpec . builder ( \"makeTacoHealthy\" ) . addParameter ( \"taco\" , taco ) . beginControlFlow ( \"for (ingredient %M taco)\" , iterator ) . addStatement ( \"if (ingredient is %T) taco %M ingredient\" , meat , minusAssign ) . endControlFlow () . addStatement ( \"return taco\" ) . build () ) . build () println ( file ) KotlinPoet will import the extension operator functions and emit the operator. package com.example import com.squareup.tacos.Taco import com.squareup.tacos.ingredient.Meat import com.squareup.tacos.internal.iterator import com.squareup.tacos.internal.minusAssign fun makeTacoHealthy ( taco : Taco ) { for ( ingredient in taco ) { if ( ingredient is Meat ) taco -= ingredient } return taco }","title":"MemberName and operators"},{"location":"#n-for-names","text":"Generated code is often self-referential. Use %N to refer to another generated declaration by its name. Here\u2019s a method that calls another: fun byteToHex ( b : Int ): String { val result = CharArray ( 2 ) result [ 0 ] = hexDigit (( b ushr 4 ) and 0 xf ) result [ 1 ] = hexDigit ( b and 0 xf ) return String ( result ) } fun hexDigit ( i : Int ): Char { return ( if ( i < 10 ) i + '0' . toInt () else i - 10 + 'a' . toInt ()). toChar () } When generating the code above, we pass the hexDigit() method as an argument to the byteToHex() method using %N : val hexDigit = FunSpec . builder ( \"hexDigit\" ) . addParameter ( \"i\" , Int :: class ) . returns ( Char :: class ) . addStatement ( \"return (if (i < 10) i + '0'.toInt() else i - 10 + 'a'.toInt()).toChar()\" ) . build () val byteToHex = FunSpec . builder ( \"byteToHex\" ) . addParameter ( \"b\" , Int :: class ) . returns ( String :: class ) . addStatement ( \"val result = CharArray(2)\" ) . addStatement ( \"result[0] = %N((b ushr 4) and 0xf)\" , hexDigit ) . addStatement ( \"result[1] = %N(b and 0xf)\" , hexDigit ) . addStatement ( \"return String(result)\" ) . build () Another handy feature that %N provides is automatically escaping names that contain illegal identifier characters with double ticks. Suppose your code creates a MemberName with a Kotlin keyword as the simple name: val taco = ClassName ( \"com.squareup.tacos\" , \"Taco\" ) val packager = ClassName ( \"com.squareup.tacos\" , \"TacoPackager\" ) val file = FileSpec . builder ( \"com.example\" , \"Test\" ) . addFunction ( FunSpec . builder ( \"packageTacos\" ) . addParameter ( \"tacos\" , LIST . parameterizedBy ( taco )) . addParameter ( \"packager\" , packager ) . addStatement ( \"packager.%N(tacos)\" , packager . member ( \"package\" )) . build () ) . build () %N will escape the name for you, ensuring that the output will pass compilation: package com.example import com.squareup.tacos.Taco import com.squareup.tacos.TacoPackager import kotlin.collections.List fun packageTacos ( tacos : List < Taco > , packager : TacoPackager ) { packager . `package` ( tacos ) }","title":"%N for Names"},{"location":"#l-for-literals","text":"Although Kotlin\u2019s string templates usually work well in cases when you want to include literals into generated code, KotlinPoet offers additional syntax inspired-by but incompatible-with String.format() . It accepts %L to emit a literal value in the output. This works just like Formatter \u2018s %s : private fun computeRange ( name : String , from : Int , to : Int , op : String ): FunSpec { return FunSpec . builder ( name ) . returns ( Int :: class ) . addStatement ( \"var result = 0\" ) . beginControlFlow ( \"for (i in %L until %L)\" , from , to ) . addStatement ( \"result = result %L i\" , op ) . endControlFlow () . addStatement ( \"return result\" ) . build () } Literals are emitted directly to the output code with no escaping. Arguments for literals may be strings, primitives, and a few KotlinPoet types described below.","title":"%L for Literals"},{"location":"#code-block-format-strings","text":"Code blocks may specify the values for their placeholders in a few ways. Only one style may be used for each operation on a code block.","title":"Code block format strings"},{"location":"#relative-arguments","text":"Pass an argument value for each placeholder in the format string to CodeBlock.add() . In each example, we generate code to say \u201cI ate 3 tacos\u201d CodeBlock . builder (). add ( \"I ate %L %L\" , 3 , \"tacos\" )","title":"Relative Arguments"},{"location":"#positional-arguments","text":"Place an integer index (1-based) before the placeholder in the format string to specify which argument to use. CodeBlock . builder (). add ( \"I ate %2L %1L\" , \"tacos\" , 3 )","title":"Positional Arguments"},{"location":"#named-arguments","text":"Use the syntax %argumentName:X where X is the format character and call CodeBlock.addNamed() with a map containing all argument keys in the format string. Argument names use characters in a-z , A-Z , 0-9 , and _ , and must start with a lowercase character. val map = LinkedHashMap < String , Any > () map += \"food\" to \"tacos\" map += \"count\" to 3 CodeBlock . builder (). addNamed ( \"I ate %count:L %food:L\" , map )","title":"Named Arguments"},{"location":"#functions","text":"All of the above functions have a code body. Use KModifier.ABSTRACT to get a function without any body. This is only legal if it is enclosed by an abstract class or an interface. val flux = FunSpec . builder ( \"flux\" ) . addModifiers ( KModifier . ABSTRACT , KModifier . PROTECTED ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addModifiers ( KModifier . ABSTRACT ) . addFunction ( flux ) . build () Which generates this: abstract class HelloWorld { protected abstract fun flux () } The other modifiers work where permitted. Methods also have parameters, varargs, KDoc, annotations, type variables, return type and receiver type for extension functions. All of these are configured with FunSpec.Builder .","title":"Functions"},{"location":"#extension-functions","text":"Extension functions can be generated by specifying a receiver . val square = FunSpec . builder ( \"square\" ) . receiver ( Int :: class ) . returns ( Int :: class ) . addStatement ( \"var s = this * this\" ) . addStatement ( \"return s\" ) . build () Which outputs: fun Int . square (): Int { val s = this * this return s }","title":"Extension functions"},{"location":"#single-expression-functions","text":"KotlinPoet can recognize single-expression functions and print them out properly. It treats each function with a body that starts with return as a single-expression function: val abs = FunSpec . builder ( \"abs\" ) . addParameter ( \"x\" , Int :: class ) . returns ( Int :: class ) . addStatement ( \"return if (x < 0) -x else x\" ) . build () Which outputs: fun abs ( x : Int ): Int = if ( x < 0 ) - x else x","title":"Single-expression functions"},{"location":"#default-function-arguments","text":"Consider the example below. Function argument b has a default value of 0 to avoid overloading this function. fun add ( a : Int , b : Int = 0 ) { print ( \"a + b = ${ a + b } \" ) } Use the defaultValue() builder function to declare default value for a function argument. FunSpec . builder ( \"add\" ) . addParameter ( \"a\" , Int :: class ) . addParameter ( ParameterSpec . builder ( \"b\" , Int :: class ) . defaultValue ( \"%L\" , 0 ) . build () ) . addStatement ( \"print(\\\"a + b = ${ a + b } \\\")\" ) . build ()","title":"Default function arguments"},{"location":"#spaces-wrap-by-default","text":"In order to provide meaningful formatting, KotlinPoet would replace spaces, found in blocks of code, with new line symbols, in cases when the line of code exceeds the length limit. Let\u2019s take this function for example: val funSpec = FunSpec . builder ( \"foo\" ) . addStatement ( \"return (100..10000).map { number -> number * number }.map { number -> number.toString() }.also { string -> println(string) }\" ) . build () Depending on where it\u2019s found in the file, it may end up being printed out like this: fun foo () = ( 100. . 10000 ). map { number -> number * number }. map { number -> number . toString () }. also { string -> println ( string ) } Unfortunately this code is broken: the compiler expects also and { to be on the same line. KotlinPoet is unable to understand the context of the expression and fix the formatting for you, but there\u2019s a trick you can use to declare a non-breaking space - use the \u00b7 symbol where you would otherwise use a space. Let\u2019s apply this to our example: val funSpec = FunSpec . builder ( \"foo\" ) . addStatement ( \"return (100..10000).map\u00b7{ number -> number * number }.map\u00b7{ number -> number.toString() }.also\u00b7{ string -> println(string) }\" ) . build () This will now produce the following result: fun foo () = ( 100. . 10000 ). map { number -> number * number }. map { number -> number . toString () }. also { string -> println ( string ) } The code is now correct and will compile properly. It still doesn\u2019t look perfect - you can play with replacing other spaces in the code block with \u00b7 symbols to achieve better formatting.","title":"Spaces wrap by default!"},{"location":"#constructors","text":"FunSpec is a slight misnomer; it can also be used for constructors: val flux = FunSpec . constructorBuilder () . addParameter ( \"greeting\" , String :: class ) . addStatement ( \"this.%N = %N\" , \"greeting\" , \"greeting\" ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addProperty ( \"greeting\" , String :: class , KModifier . PRIVATE ) . addFunction ( flux ) . build () Which generates this: class HelloWorld { private val greeting : String constructor ( greeting : String ) { this . greeting = greeting } } For the most part, constructors work just like methods. When emitting code, KotlinPoet will place constructors before methods in the output file. Often times you\u2019ll need to generate the primary constructor for a class: val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . primaryConstructor ( flux ) . addProperty ( \"greeting\" , String :: class , KModifier . PRIVATE ) . build () This code, however, generates the following: class HelloWorld ( greeting : String ) { private val greeting : String init { this . greeting = greeting } } By default, KotlinPoet won\u2019t merge primary constructor parameters and properties, even if they share the same name. To achieve the effect, you have to tell KotlinPoet that the property is initialized via the constructor parameter: val flux = FunSpec . constructorBuilder () . addParameter ( \"greeting\" , String :: class ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . primaryConstructor ( flux ) . addProperty ( PropertySpec . builder ( \"greeting\" , String :: class ) . initializer ( \"greeting\" ) . addModifiers ( KModifier . PRIVATE ) . build () ) . build () Now we\u2019re getting the following output: class HelloWorld ( private val greeting : String ) Notice that KotlinPoet omits {} for classes with empty bodies.","title":"Constructors"},{"location":"#parameters","text":"Declare parameters on methods and constructors with either ParameterSpec.builder() or FunSpec \u2018s convenient addParameter() API: val android = ParameterSpec . builder ( \"android\" , String :: class ) . defaultValue ( \"\\\"pie\\\"\" ) . build () val welcomeOverlords = FunSpec . builder ( \"welcomeOverlords\" ) . addParameter ( android ) . addParameter ( \"robot\" , String :: class ) . build () The code above generates: fun welcomeOverlords ( android : String = \"pie\" , robot : String ) { } The extended Builder form is necessary when the parameter has annotations (such as @Inject ).","title":"Parameters"},{"location":"#properties","text":"Like parameters, properties can be created either with builders or by using convenient helper methods: val android = PropertySpec . builder ( \"android\" , String :: class ) . addModifiers ( KModifier . PRIVATE ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addProperty ( android ) . addProperty ( \"robot\" , String :: class , KModifier . PRIVATE ) . build () Which generates: class HelloWorld { private val android : String private val robot : String } The extended Builder form is necessary when a field has KDoc, annotations, or a field initializer. Field initializers use the same String.format() -like syntax as the code blocks above: val android = PropertySpec . builder ( \"android\" , String :: class ) . addModifiers ( KModifier . PRIVATE ) . initializer ( \"%S + %L\" , \"Oreo v.\" , 8.1 ) . build () Which generates: private val android : String = \"Oreo v.\" + 8.1 By default PropertySpec.Builder produces val properties. Use mutable() if you need a var : val android = PropertySpec . builder ( \"android\" , String :: class ) . mutable () . addModifiers ( KModifier . PRIVATE ) . initializer ( \"%S + %L\" , \"Oreo v.\" , 8.1 ) . build ()","title":"Properties"},{"location":"#inline-properties","text":"The way KotlinPoet models inline properties deserves special mention. The following snippet of code: val android = PropertySpec . builder ( \"android\" , String :: class ) . mutable () . addModifiers ( KModifier . INLINE ) . build () will produce an error: java.lang.IllegalArgumentException: KotlinPoet doesn't allow setting the inline modifier on properties. You should mark either the getter, the setter, or both inline. Indeed, a property marked with inline should have at least one accessor which will be inlined by the compiler. Let\u2019s add a getter to this property: val android = PropertySpec . builder ( \"android\" , String :: class ) . mutable () . getter ( FunSpec . getterBuilder () . addModifiers ( KModifier . INLINE ) . addStatement ( \"return %S\" , \"foo\" ) . build () ) . build () The result is the following: var android : kotlin . String inline get () = \"foo\" Now, what if we wanted to add a non-inline setter to the property above? We can do so without modifying any of the code we wrote previously: val android = PropertySpec . builder ( \"android\" , String :: class ) . mutable () . getter ( FunSpec . getterBuilder () . addModifiers ( KModifier . INLINE ) . addStatement ( \"return %S\" , \"foo\" ) . build () ) . setter ( FunSpec . setterBuilder () . addParameter ( \"value\" , String :: class ) . build () ) . build () We get the expected result: var android : kotlin . String inline get () = \"foo\" set ( `value` ) { } Finally, if we go back and add KModifier.INLINE to the setter, KotlinPoet can wrap it nicely and produce the following result: inline var android : kotlin . String get () = \"foo\" set ( `value` ) { } Removing the modifier from either the getter or the setter will unwrap the expression back. If, on the other hand, KotlinPoet had allowed marking a property inline directly, the programmer would have had to manually add/remove the modifier whenever the state of the accessors changes in order to get correct and compilable output. We\u2019re solving this problem by making accessors the source of truth for the inline modifier.","title":"Inline properties"},{"location":"#interfaces","text":"KotlinPoet has no trouble with interfaces. Note that interface methods must always be ABSTRACT . The modifier is necessary when defining the interface: val helloWorld = TypeSpec . interfaceBuilder ( \"HelloWorld\" ) . addProperty ( \"buzz\" , String :: class ) . addFunction ( FunSpec . builder ( \"beep\" ) . addModifiers ( KModifier . ABSTRACT ) . build () ) . build () But these modifiers are omitted when the code is generated. These are the default so we don\u2019t need to include them for kotlinc \u2018s benefit! interface HelloWorld { val buzz : String fun beep () } Kotlin 1.4 adds support for functional interfaces via fun interface syntax. To create this in KotlinPoet, use TypeSpec.funInterfaceBuilder() . val helloWorld = TypeSpec . funInterfaceBuilder ( \"HelloWorld\" ) . addFunction ( FunSpec . builder ( \"beep\" ) . addModifiers ( KModifier . ABSTRACT ) . build () ) . build () // Generates... fun interface HelloWorld { fun beep () }","title":"Interfaces"},{"location":"#objects","text":"KotlinPoet supports objects: val helloWorld = TypeSpec . objectBuilder ( \"HelloWorld\" ) . addProperty ( PropertySpec . builder ( \"buzz\" , String :: class ) . initializer ( \"%S\" , \"buzz\" ) . build () ) . addFunction ( FunSpec . builder ( \"beep\" ) . addStatement ( \"println(%S)\" , \"Beep!\" ) . build () ) . build () Similarly, you can create companion objects and add them to classes using addType() : val companion = TypeSpec . companionObjectBuilder () . addProperty ( PropertySpec . builder ( \"buzz\" , String :: class ) . initializer ( \"%S\" , \"buzz\" ) . build () ) . addFunction ( FunSpec . builder ( \"beep\" ) . addStatement ( \"println(%S)\" , \"Beep!\" ) . build () ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addType ( companion ) . build () You can provide an optional name for a companion object.","title":"Objects"},{"location":"#enums","text":"Use enumBuilder to create the enum type, and addEnumConstant() for each value: val helloWorld = TypeSpec . enumBuilder ( \"Roshambo\" ) . addEnumConstant ( \"ROCK\" ) . addEnumConstant ( \"SCISSORS\" ) . addEnumConstant ( \"PAPER\" ) . build () To generate this: enum class Roshambo { ROCK , SCISSORS , PAPER } Fancy enums are supported, where the enum values override methods or call a superclass constructor. Here\u2019s a comprehensive example: val helloWorld = TypeSpec . enumBuilder ( \"Roshambo\" ) . primaryConstructor ( FunSpec . constructorBuilder () . addParameter ( \"handsign\" , String :: class ) . build () ) . addEnumConstant ( \"ROCK\" , TypeSpec . anonymousClassBuilder () . addSuperclassConstructorParameter ( \"%S\" , \"fist\" ) . addFunction ( FunSpec . builder ( \"toString\" ) . addModifiers ( KModifier . OVERRIDE ) . addStatement ( \"return %S\" , \"avalanche!\" ) . returns ( String :: class ) . build () ) . build () ) . addEnumConstant ( \"SCISSORS\" , TypeSpec . anonymousClassBuilder () . addSuperclassConstructorParameter ( \"%S\" , \"peace\" ) . build () ) . addEnumConstant ( \"PAPER\" , TypeSpec . anonymousClassBuilder () . addSuperclassConstructorParameter ( \"%S\" , \"flat\" ) . build () ) . addProperty ( PropertySpec . builder ( \"handsign\" , String :: class , KModifier . PRIVATE ) . initializer ( \"handsign\" ) . build () ) . build () Which generates this: enum class Roshambo ( private val handsign : String ) { ROCK ( \"fist\" ) { override fun toString (): String = \"avalanche!\" }, SCISSORS ( \"peace\" ), PAPER ( \"flat\" ); }","title":"Enums"},{"location":"#anonymous-inner-classes","text":"In the enum code, we used TypeSpec.anonymousClassBuilder() . Anonymous inner classes can also be used in code blocks. They are values that can be referenced with %L : val comparator = TypeSpec . anonymousClassBuilder () . addSuperinterface ( Comparator :: class . parameterizedBy ( String :: class )) . addFunction ( FunSpec . builder ( \"compare\" ) . addModifiers ( KModifier . OVERRIDE ) . addParameter ( \"a\" , String :: class ) . addParameter ( \"b\" , String :: class ) . returns ( Int :: class ) . addStatement ( \"return %N.length - %N.length\" , \"a\" , \"b\" ) . build () ) . build () val helloWorld = TypeSpec . classBuilder ( \"HelloWorld\" ) . addFunction ( FunSpec . builder ( \"sortByLength\" ) . addParameter ( \"strings\" , List :: class . parameterizedBy ( String :: class )) . addStatement ( \"%N.sortedWith(%L)\" , \"strings\" , comparator ) . build () ) . build () This generates a method that contains a class that contains a method: class HelloWorld { fun sortByLength ( strings : List < String > ) { strings . sortedWith ( object : Comparator < String > { override fun compare ( a : String , b : String ): Int = a . length - b . length }) } } One particularly tricky part of defining anonymous inner classes is the arguments to the superclass constructor. To pass them use TypeSpec.Builder \u2018s addSuperclassConstructorParameter() method.","title":"Anonymous Inner Classes"},{"location":"#annotations","text":"Simple annotations are easy: val test = FunSpec . builder ( \"test string equality\" ) . addAnnotation ( Test :: class ) . addStatement ( \"assertThat(%1S).isEqualTo(%1S)\" , \"foo\" ) . build () Which generates this function with an @Test annotation: @Test fun `test string equality` () { assertThat ( \"foo\" ). isEqualTo ( \"foo\" ) } Use AnnotationSpec.builder() to set properties on annotations: val logRecord = FunSpec . builder ( \"recordEvent\" ) . addModifiers ( KModifier . ABSTRACT ) . addAnnotation ( AnnotationSpec . builder ( Headers :: class ) . addMember ( \"accept = %S\" , \"application/json; charset=utf-8\" ) . addMember ( \"userAgent = %S\" , \"Square Cash\" ) . build () ) . addParameter ( \"logRecord\" , LogRecord :: class ) . returns ( LogReceipt :: class ) . build () Which generates this annotation with accept and userAgent properties: @Headers ( accept = \"application/json; charset=utf-8\" , userAgent = \"Square Cash\" ) abstract fun recordEvent ( logRecord : LogRecord ): LogReceipt When you get fancy, annotation values can be annotations themselves. Use %L for embedded annotations: val headerList = ClassName ( \"\" , \"HeaderList\" ) val header = ClassName ( \"\" , \"Header\" ) val logRecord = FunSpec . builder ( \"recordEvent\" ) . addModifiers ( KModifier . ABSTRACT ) . addAnnotation ( AnnotationSpec . builder ( headerList ) . addMember ( \"[\\n\u21e5%L,\\n%L\u21e4\\n]\" , AnnotationSpec . builder ( header ) . addMember ( \"name = %S\" , \"Accept\" ) . addMember ( \"value = %S\" , \"application/json; charset=utf-8\" ) . build (), AnnotationSpec . builder ( header ) . addMember ( \"name = %S\" , \"User-Agent\" ) . addMember ( \"value = %S\" , \"Square Cash\" ) . build () ) . build () ) . addParameter ( \"logRecord\" , logRecordName ) . returns ( logReceipt ) . build () Which generates this: @HeaderList ( [ Header ( name = \"Accept\" , value = \"application/json; charset=utf-8\" ), Header ( name = \"User-Agent\" , value = \"Square Cash\" ) ] ) abstract fun recordEvent ( logRecord : LogRecord ): LogReceipt KotlinPoet supports use-site targets for annotations: val utils = FileSpec . builder ( \"com.example\" , \"Utils\" ) . addAnnotation ( AnnotationSpec . builder ( JvmName :: class ) . useSiteTarget ( UseSiteTarget . FILE ) . build () ) . addFunction ( FunSpec . builder ( \"abs\" ) . receiver ( Int :: class ) . returns ( Int :: class ) . addStatement ( \"return if (this < 0) -this else this\" ) . build () ) . build () Will output this: @file : JvmName package com.example import kotlin.Int import kotlin.jvm.JvmName fun Int . abs (): Int = if ( this < 0 ) - this else this","title":"Annotations"},{"location":"#type-aliases","text":"KotlinPoet provides API for creating Type Aliases, which supports simple class names, parameterized types and lambdas: val k = TypeVariableName ( \"K\" ) val t = TypeVariableName ( \"T\" ) val fileTable = Map :: class . asClassName () . parameterizedBy ( k , Set :: class . parameterizedBy ( File :: class )) val predicate = LambdaTypeName . get ( parameters = arrayOf ( t ), returnType = Boolean :: class . asClassName () ) val helloWorld = FileSpec . builder ( \"com.example\" , \"HelloWorld\" ) . addTypeAlias ( TypeAliasSpec . builder ( \"Word\" , String :: class ). build ()) . addTypeAlias ( TypeAliasSpec . builder ( \"FileTable\" , fileTable ) . addTypeVariable ( k ) . build () ) . addTypeAlias ( TypeAliasSpec . builder ( \"Predicate\" , predicate ) . addTypeVariable ( t ) . build () ) . build () Which generates the following: package com.example import java.io.File import kotlin.Boolean import kotlin.String import kotlin.collections.Map import kotlin.collections.Set typealias Word = String typealias FileTable < K > = Map < K , Set < File >> typealias Predicate < T > = ( T ) -> Boolean","title":"Type Aliases"},{"location":"#callable-references","text":"Callable references to constructors, functions, and properties may be emitted via: ClassName.constructorReference() for constructors MemberName.reference() for functions and properties For example, val helloClass = ClassName ( \"com.example.hello\" , \"Hello\" ) val worldFunction : MemberName = helloClass . member ( \"world\" ) val byeProperty : MemberName = helloClass . nestedClass ( \"World\" ). member ( \"bye\" ) val factoriesFun = FunSpec . builder ( \"factories\" ) . addStatement ( \"val hello = %L\" , helloClass . constructorReference ()) . addStatement ( \"val world = %L\" , worldFunction . reference ()) . addStatement ( \"val bye = %L\" , byeProperty . reference ()) . build () FileSpec . builder ( \"com.example\" , \"HelloWorld\" ) . addFunction ( factoriesFun ) . build () would generate: package com.example import com.example.hello.Hello fun factories () { val hello = :: Hello val world = Hello :: world val bye = Hello . World :: bye } Top-level classes and members with conflicting names may require aliased imports, as with member names .","title":"Callable References"},{"location":"#kotlin-reflect","text":"To generate source code from any KType , including information that\u2019s not accessible to the builtin reflection APIs, KotlinPoet depends on kotlin-reflect . kotlin-reflect can read the metadata of your classes and access this extra information. KotlinPoet can for an example, read the type parameters and their variance from a generic KType and generate appropriate source code. kotlin-reflect is a relatively big dependency though and in some cases it is desirable to remove it from the final executable to save some space and/or simplify the proguard/R8 setup (for example for a Gradle plugin that generates Kotlin code). It is possible to do so and still use most of the KotlinPoet APIs: dependencies { implementation ( \"com.squareup:kotlinpoet:<version>\" ) { exclude ( module = \"kotlin-reflect\" ) } } The main APIs that require kotlin-reflect are KType.asTypeName() and typeNameOf<T>() . If you\u2019re calling one of these without kotlin-reflect in the classpath and the type is generic or has annotations you will get a crash. You can replace it with code that passes type parameters or annotations explicitly and doesn\u2019t need kotlin-reflect . For example: // Replace // kotlin-reflect needed val typeName = typeNameOf < List < Int? >> () // With // kotlin-reflect not needed val typeName = List :: class . asClassName (). parameterizedBy ( Int :: class . asClassName (). copy ( nullable = true ))","title":"kotlin-reflect"},{"location":"#download","text":"Download the latest .jar or depend via Maven: <dependency> <groupId> com.squareup </groupId> <artifactId> kotlinpoet </artifactId> <version> 1.11.0 </version> </dependency> or Gradle: implementation ( \"com.squareup:kotlinpoet:1.11.0\" ) Snapshots of the development version are available in Sonatype\u2019s snapshots repository .","title":"Download"},{"location":"#license","text":"Copyright 2017 Square, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Change Log \u00b6 Version 1.11.0 \u00b6 2022-03-24 Thanks to @liujingxing and @BoD for contributing to this release. New: Kotlin scripting support in FileSpec . val spec = FileSpec . scriptBuilder ( \"Taco\" ) . addStatement ( \"println(%S)\" , \"hello world!\" ) . addKotlinDefaultImports () . build () Generates a Taco.kts file with the following contents: println ( \"hello world!\" ) New: Emit trailing commas for multi-line parameters and annotations. New: Add KSAnnotation.toAnnotationSpec() . New: Add Unit and CharSequence conversions in javapoet-interop . New: Add support for default imports in FileSpec . This is particularly oriented at scripting support, but can also be used in non-script files. New: Update to Kotlin 1.6.10. Fix: Fail compilation if you only pass one string to ClassName . Fix: Inline val property if its getter is inline . Fix: Add yield to the list of reserved keywords. Fix: Enforce only allowed parameter modifiers in ParameterSpec (i.e. crossinline , vararg , and noinline ). Fix: Fix CodeBlock s in class delegation getting toString() \u2018d instead of participating in code writing. Fix: Error when attempting to convert KSP error types (i.e. if KSType.isError is true) to TypeName . Version 1.10.2 \u00b6 2021-10-22 Thanks to @glureau and @goooler for contributing to this release. New: Switch AnnotationSpec.get() to use the arrayOf() syntax instead of [] . Fix: Don\u2019t wrap aliasing imports with long package names. Fix: Don\u2019t wrap type names inside line comments. Fix: Ignore Java\u2019s @Deprecated annotations on synthetic methods for annotations. Version 1.10.1 \u00b6 2021-09-21 Thanks to @evant for contributing to this release. Fix: Correct generation of typealiases with type args in KSP interop. Fix: Add missing default TypeParameterResolver.EMPTY argument to fun KSTypeArgument.toTypeName in KSP interop. Version 1.10.0 \u00b6 2021-09-20 Thanks to @martinbonnin , @idanakav , @goooler , and @anandwana001 for contributing to this release. New: Add a new KSP interop artifact. See docs for more details. New: Add a new JavaPoet interop artifact. See docs for more details. New: Allow copying a ParameterizedTypeName with new type arguments via new copy() overload. kotlinx-metadata artifacts have been consolidated to a single com.squareup:kotlinpoet-metadata maven artifact. The previous kotlinpoet-metadata-* subartifacts are no longer published. New: TypeNameAliasTag has been moved to KotlinPoet\u2019s main artifact under TypeAliasTag , for reuse with KSP interop. ImmutableKm* classes have been removed. They were deemed to be a needless abstraction over the base kotlinx-metadata Km types. All usages of these should be substituted with their non-immutable base types. Fix: Fix self-referencing type variables in metadata parsing. Fix: Use delicate APIs rather than noisy logging ones when converting annotation mirrors in AnnotationSpec.get . Fix: Update error message when metadata cannot be read to a more actionable one. Fix: Avoid escaping already escaped strings. Add docs about kotlin-reflect usage. Avoid using kotlin-reflect for looking up Unit types where possible. Test all the way up to JDK 17. Update Kotlin to 1.5.31. Version 1.9.0 \u00b6 2021-06-22 New: Kotlin 1.5.10. New: Previously deprecated API to interop with Java reflection and Mirror API have been un-deprecated and marked with @DelicateKotlinPoetApi annotation. New: CodeBlock.Builder.withIndent helper function. New: Allow changing initializers and default values in ParameterSpec.Builder and PropertySpec.Builder after they were set. New: MemberName.isExtension property that instructs KotlinPoet to always import the member, even if conflicting declarations are present in the same scope. Fix: Escape member names that only contain underscores. Fix: Always emit an empty primary constructor if it was set via TypeSpec.primaryConstructor . Version 1.8.0 \u00b6 2021-03-29 New: Kotlin 1.4.31. New: Add KModifier.VALUE to support value class declarations. New: Allow using a custom ClassLoader with ReflectiveClassInspector . New: Update to kotlinx-metadata 0.2.0. Fix: Ensure ImmutableKmProperty.toMutable() copies fieldSignature . Fix: Prevent name clashes between an imported MemberName and a member in current scope. Fix: Prevent name clashes between a type and a supertype with the same name. Fix: Don\u2019t generate empty body for expect and external functions. Fix: Don\u2019t allow expect or external classes to initialize supertypes. Fix: Disallow delegate constructor calls in external classes. Fix: Allow non-public primary constructors inside inline/value classes. Fix: Allow init blocks inside inline/value classes. Fix: Omit redundant abstract modifiers on members inside interfaces Version 1.7.2 \u00b6 2020-10-20 New: Detect expression bodies with return\u00b7 and throw\u00b7 prefixes. Fix: Omit visibility modifiers on custom accessors. Version 1.7.1 \u00b6 2020-10-15 Fix: 1.7.0 was published using JDK 11 which set \"org.gradle.jvm.version\" to \"11\" in Gradle metadata, making it impossible to use the library on earlier Java versions (see #999 ). 1.7.1 is published with JDK 8, which fixes the problem. Version 1.7.0 \u00b6 2020-10-14 New: Kotlin 1.4.10. New: Generated code is now compatible with the explicit API mode by default. New: Escape soft and modifier keywords, in addition to hard keywords. New: Improve enum constants generation for cleaner diffs. New: Disallow setters on immutable properties. New: Ensure trailing new lines in expression bodies. New: Ensure trailing new lines after parameterless custom setters. Fix: Don\u2019t auto-convert properties with custom accessors to primary constructor properties. Fix: Don\u2019t allow parameterless setters with body. Fix: Prevent auto-wrapping spaces inside escaped keywords. Version 1.6.0 \u00b6 2020-05-28 New: Deprecate Mirror API integrations. Mirror API integrations, such as TypeElement.asClassName() and FunSpec.overriding(ExecutableElement) , are being deprecated in this release. These KotlinPoet APIs are most often used in annotation processors. Since kapt runs annotation processors over stubs, which are Java files, a lot of the Kotlin-specific information gets lost in translation and cannot be accessed by KotlinPoet through the Mirror API integrations. Examples include: Alias types, such as kotlin.String , get converted to their JVM representations, such as java.lang.String . Type nullability information is not accessible. suspend functions are seen as simple functions with an additional Continuation parameter. The correct solution is to switch to KotlinPoet-metadata or KotlinPoet-metadata-specs API, which fetches Kotlin-specific information from the @Metadata annotation and produces correct KotlinPoet Specs. We may explore adding new metadata-based alternatives to the deprecated APIs in the future. New: Kotlin 1.3.72. New: Improve MemberName to support operator overloading. New: Support generics in AnnotationSpec . New: Add support for functional interfaces. New: Make more FunSpec.Builder members public for easier mutation. Fix: Properly propagate implicit type and function modifiers in nested declarations. Fix: Properly escape type names containing $ character. Fix: Don\u2019t emit LambdaTypeName annotations twice. Fix: Preserve tags in TypeName.copy() . Version 1.5.0 \u00b6 2020-01-09 KotlinPoet now targets JDK8, which means that executing a build that includes KotlinPoet as a dependency on a machine with an older version of JDK installed won\u2019t work. This has no effect on the code that KotlinPoet produces : the code can still be compiled against JDK6, as long as it doesn\u2019t use any features that were introduced in newer releases. New: Kotlin 1.3.61. New: Add support for processing FileFacades in KotlinPoet-metadata. New: Add support for inner nested and companion objects on annotation classes. New: Improve error messages for mismatched open/close statement characters. New: Tag AnnotationSpec s with the annotation mirror when available. New: Include annotations on enum entries when creating TypeSpec s from metadata. Fix: Fix metadata parsing for types. Fix: Allow file names that are Kotlin keywords. Fix: Properly escape type alias names with backticks. Fix: Allow creating TypeSpec s with names that can be escaped with backticks. Fix: Properly escape enum constant names with backticks. Fix: Maintain proper ordering of properties and initializers when emitting a TypeSpec . Note : with this change, any properties declared after any initializer blocks will not be added to the primary constructor and will instead be emitted inside the TypeSpec body. Fix: Don\u2019t emit a leading new line if type KDoc is empty but parameter KDocs are present. Fix: Ensure KotlinPoet-metadata resolves package names properly. ## Version 1.4.4 2019-11-16 Fix: Support reified inline types in KotlinPoet-metadata. Version 1.4.3 \u00b6 2019-10-30 Fix: Don\u2019t emit stubs for abstract functions in KotlinPoet-metadata. Version 1.4.2 \u00b6 2019-10-28 Fix: Properly handle abstract elements in KotlinPoet-metadata. Fix: Properly handle typealiases in KotlinPoet-metadata. Fix: Properly render % symbols at the end of KDocs. Version 1.4.1 \u00b6 2019-10-18 New: Add annotations support to TypeAliasSpec . New: Read type annotations from Kotlin Metadata . New: Introduce ImmutableKmDeclarationContainer . Fix: Use full package name for shading auto-common . Fix: Support reading self-type variables (e.g. Asset<A : Asset<A>> ) from Kotlin Metadata . Version 1.4.0 \u00b6 2019-09-24 New: This release introduces the new KotlinPoet-metadata API that makes it easy to introspect Kotlin types and build KotlinPoet Specs based on that data. The strategy for type introspection is driven by ClassInspector , which is a basic interface for looking up JVM information about a given Class. This optionally is used by the toTypeSpec() / toFileSpec() APIs in kotlinpoet-metadata-specs artifact to inform about Classes with information that isn\u2019t present in metadata (overrides, JVM modifiers, etc). There are two batteries-included implementations available in ReflectiveClassInspector (for reflection) and ElementsClassInspector (for the javax Elements API in annotation processing). These implementations are available through their respective kotlinpoet-classinspector-* artifacts. For more information refer to the KotlinPoet-metadata-specs README . At the time of this release the API is in experimental mode and has to be opted into via the KotlinPoetMetadataPreview annotation. New: Kotlin 1.3.50. New: A new constructor to simplify creation of ParameterSpec instances. New: New ClassName constructors. New: TypeName and subclasses can now store tags. New: Optional parameters added to toBuilder() methods of most Specs. New: List overrides for Spec methods that accept vararg s. New: CodeBlock.Builder.clear() helper method. New: FunSpec.Builder.clearBody() helper method. Fix: Properly escape enum constant names. Fix: Ensure trailing newlines in KDoc and function bodies. Fix: TypeVariableName s with empty bounds will now default to Any? . Fix: Don\u2019t emit parens for primary constructors. Fix: ClassName s with empty simple names are not allowed anymore. Fix: Throw if names contain illegal characters that can\u2019t be escaped with backticks. Version 1.3.0 \u00b6 2019-05-30 New: Don\u2019t inline annotations in the primary constructor. New: Force new lines when emitting primary constructors. New: Support using MemberNames as arguments to %N. New: Add more ClassName constants: ClassName.STRING, ClassName.LIST, etc. New: Add ClassName.constructorReference() and MemberName.reference(). New: Make %N accept MemberNames. New: Escape spaces in import aliases. New: Escape spaces in ClassNames. New: Escape spaces in MemberNames. New: Escape imports containing spaces. New: Escape package name containing spaces. New: Use 2-space indents. New: Only indent one level on annotation values. Fix: Pass only unique originating elements to Filer. Fix: Fix bug with MemberNames in same package nested inside a class. Version 1.2.0 \u00b6 2019-03-28 New: Add writeTo(Filer) and originating element API. New: Make *Spec types taggable. New: Make FunSpec.Builder#addCode take vararg Any?. Fix: Import members from default package. Fix: Add non-wrapping spaces in control flow creation methods. Fix: Named \u201cvalue\u201d argument being omitted in annotation array types. Version 1.1.0 \u00b6 2019-02-28 New: Kotlin 1.3.21. New: Support referencing members using %M and MemberName type. New: Add extensions for getting a MemberName from a ClassName , KClass and Class . New: Allow passing CodeBlock s as arguments to %P . New: Allow interface delegation for objects. Fix: Don\u2019t emit visible whitespace in toString() . Fix: Prevent line wrapping in weird places inside function signature. Fix: No line wrapping between val and property name. Fix: Allow passing line prefix into LineWrapper to enable proper line wrapping in KDoc. Fix: Add newline for TypeSpec Kdoc with no tags. Fix: Add newline for remaining Specs. Fix: Fix kdoc formatting for property getter/setters. Fix: Don\u2019t wrap single line comments inside FunSpec . Fix: Add non-wrapping package name. Fix: Remove n^2 algorithm in CodeWriter.resolve() by precomputing all of the nested simple names of a TypeSpec . Fix: Fix edge case with empty enum classes. Fix: Fix Nullable Type Parameter handling in KType.asTypeName() . Fix: Fix incorrect long comment wrapping in FileSpec . Fix: Attach primary constructor param/property KDoc to the element vs emitting it inside the type header. Version 1.0.1 \u00b6 2019-01-02 New: Allow enums without constants. New: Improved formatting of TypeSpec KDoc. New: Support @property and @param KDoc tags in TypeSpec. Fix: Use pre-formatted strings for arguments to %P. Version 1.0.0 \u00b6 2018-12-10 New: Kotlin 1.3.11. Fix: Prevent wrapping in import statements. Version 1.0.0-RC3 \u00b6 2018-11-28 New: Kotlin 1.3.10. New: Add %P placeholder for string templates. New: Add support for receiver kdoc. New: Avoid emitting Unit as return type. New: Add support for empty setters. New: Add checks for inline classes. New: Escape property and variable names if keywords. New: Replace %> , %< , %[ , %] placeholders with \u21e5 , \u21e4 , \u00ab , \u00bb . New: Replace %W with space, and add \u00b7 as a non-breaking space. New: Change TypeName to sealed class. New: Documentation improvements. New: Replace TypeName modifier methods with copy() . New: Rename members of WildcardTypeName to match with the producer/consumer generics model. New: Rename TypeName.nullable into TypeName.isNullable . New: Rename LambdaTypeName.suspending into LambdaTypeName.isSuspending . New: Rename TypeVariableName.reified into TypeVariableName.isReified . Fix: Emit star-projection only for types with Any? upper bound. Fix: Fold property with escaped name. Version 1.0.0-RC2 \u00b6 2018-10-22 New: Kotlin 1.2.71. New: README improvements. New: Allow opening braces and params in beginControlFlow() . New: Add KDoc to ParameterSpec , collapse into parent KDoc. New: Support TypeVariable s in PropertySpec . New: Add parens for annotated types in LambdaTypeName . New: Improve error messaging and documentation for inline properties. New: Allow sealed classes to declare abstract properties. New: Added buildCodeBlock() helper function. New: Allow using CodeBlock s with statements as property initializers and default parameter values. New: Rename NameAllocator.clone() into `NameAllocator.copy(). New: Rename TypeName.asNonNullable() to TypeName.asNonNull() . New: Remove PropertySpec.varBuilder() (use mutable() instead). New: Allow importing top-level members in default package. New: Add overloads to add KDoc to return type. Fix: Distinguishing IntArray and Array<Int> when creating TypeName . Fix: Use TypeName instead of ClassName as parameter type of plusParameter() . Fix: Keep type-parameter variance when constructing TypeName from KType . Fix: Don\u2019t validate modifiers when merging properties with primary constructor parameters. Fix: Escape $ characters in formatted strings. Fix: FileSpec.Builder blank package and subfolder fix. Fix: Append new line at end of parameter KDoc. Fix: Add parameter KDoc in toBuilder() . Version 1.0.0-RC1 \u00b6 2018-07-16 New: Escape keywords in imports and canonical class names. New: Improve external support. New: Extensions for KType and KTypeParameter . New: Add builder methods to simplify adding common kotlin.jvm annotations. New: Enums are able to have companion objects. New: Add missing primaryConstructor & companionObject to TypeSpec#toBuilder() . New: Make subtype checking vals inside Kind public. New: Escape (class/property/function/variable) names automatically if they contain space, hyphen, or other symbols. New: Improve ParameterizedTypeName API. New: Add WildcardTypeName.STAR constant. New: Expose mutable builder properties and move their validations to build-time. Fix: Use regular indents for parameter lists. Fix: Inline annotations on properties defined in primary constructor. Fix: Use Any? as the default type variable bounds. Fix: Fix importing annotated TypeName . Fix: If any primary constructor property has KDoc, put properties on new lines. Fix: Properly emit where block in type signature. Fix: Avoid type name collisions in primary constructor. Fix: Remove implicit TypeVariable bound when more bounds are added. Fix: Combine annotations and modifiers from constructor params and properties. Fix: Replace delegate constructor args along with the constructor. Version 0.7.0 \u00b6 2018-02-16 New: Increase indent to 4 spaces. New: Delegate super interfaces as constructor parameters. New: Support PropertySpec s as CodeBlock literals. New: Support KDoc for TypeAliasSpec . New: Allow for adding an initializer block inside a companion object. New: Escape name in ParameterSpec which is also a keyword. New: Escape names in statements. New: Set com.squareup.kotlinpoet as automatic module name. New: Support suspending lambda types. New: Support named LambdaTypeName parameters. New: Support dynamic type. New: Disallow wildcard imports. New: Depend on Kotlin 1.2.21. Fix: Correct handling of super-classes/interfaces on anonymous classes. Fix: Fix boundary filtering to Any? . Fix: Wrap long property initializers. Fix: Fix formatting and indentation of parameter lists. Version 0.6.0 \u00b6 2017-11-03 New: Support lambda extensions. New: Support renames in imports like import bar.Bar as bBar . New: Support extension and inline properties. New: Support reified types. New: Expose enclosed types inside LambdaTypeName . New: Depend on Kotlin Kotlin 1.1.51. New: Improved API and formatting of annotations. New: Improved multiplatform support. Fix: Escape function and package names if they are a Kotlin keyword. Fix: Properly format WildcardTypeName\u2019s class declaration. Version 0.5.0 \u00b6 2017-09-13 New: Rename addFun() to addFunction() . New: Rename KotlinFile to FileSpec . New: Rename KotlinFile.addFileAnnotation() to addAnnotation() . New: Rename KotlinFile.addFileComment() to addComment() . New: Support cross-platform code, including HEADER and IMPL modifiers. New: Support type variables for type aliases. New: Support constructor delegation. New: Support named companion objects. New: Depend on Kotlin 1.1.4-3. Fix: Format one parameter per line when there are more than two parameters. Fix: Don\u2019t emit braces when the constructor body is empty. Fix: Do not invoke superclass constructor when no primary constructor. Fix: Enforce the right modifiers on functions. Version 0.4.0 \u00b6 2017-08-08 New: Change KotlinPoet\u2019s extensions like asClassName() to be top-level functions. New: Add declaration-site variance support. New: Improve handling of single expression bodies. New: Support file annotations. New: Support imports from the top-level file. New: Accept superclass constructor parameters. New: Support primary constructors using the constructor keyword. Fix: Don\u2019t emit setter parameter types. Fix: Support Kotlin keywords in NameAllocator . Fix: Emit the right default parameters for primary constructors. Fix: Format annotations properly when used as parameters. Fix: Recognize imports when emitting nullable types. Fix: Call through to the superclass constructor when superclass has a no-args constructor. Fix: Omit class braces if all properties are declared in primary constructor. Fix: Don\u2019t emit empty class bodies. Fix: Emit the right syntax for declaring multiple generic type constraints. Fix: Support properties on objects, companions and interfaces. Fix: Use AnnotationSpec for throws. Version 0.3.0 \u00b6 2017-06-11 New: Objects and companion objects. New: TypeAliasSpec to create type aliases. New: LambdaTypeName to create lambda types. New: Collapse property declarations into constructor params. New: Extension and invoke functions for creating type names: Runnable::class.asClassName() . New: Basic support for expression bodies. New: Basic support for custom accessors. New: Remove Filer writing and originating elements concept. These stem from javac annotation processors. Fix: Generate valid annotation classes. Fix: Use KModifier for varargs. Fix: Use ParameterizedTypeName for array types. Fix: Extract Kotlin name from KClass instead of Java name. Fix: Emit valid class literals: Double::class instead of Double.class . Fix: Emit modifiers in the expected order. Fix: Emit the correct syntax for enum classes and overridden members. Version 0.2.0 \u00b6 2017-05-21 New: Flip API signatures to be (name, type) instead of (type, name). New: Support for nullable types. New: Support delegated properties. New: Extension functions. New: Support top-level properties. Fix: Inheritance should use : instead of extends and implements . Fix: Make initializerBlock emit init {} . Version 0.1.0 \u00b6 2017-05-16 Initial public release.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-1110","text":"2022-03-24 Thanks to @liujingxing and @BoD for contributing to this release. New: Kotlin scripting support in FileSpec . val spec = FileSpec . scriptBuilder ( \"Taco\" ) . addStatement ( \"println(%S)\" , \"hello world!\" ) . addKotlinDefaultImports () . build () Generates a Taco.kts file with the following contents: println ( \"hello world!\" ) New: Emit trailing commas for multi-line parameters and annotations. New: Add KSAnnotation.toAnnotationSpec() . New: Add Unit and CharSequence conversions in javapoet-interop . New: Add support for default imports in FileSpec . This is particularly oriented at scripting support, but can also be used in non-script files. New: Update to Kotlin 1.6.10. Fix: Fail compilation if you only pass one string to ClassName . Fix: Inline val property if its getter is inline . Fix: Add yield to the list of reserved keywords. Fix: Enforce only allowed parameter modifiers in ParameterSpec (i.e. crossinline , vararg , and noinline ). Fix: Fix CodeBlock s in class delegation getting toString() \u2018d instead of participating in code writing. Fix: Error when attempting to convert KSP error types (i.e. if KSType.isError is true) to TypeName .","title":"Version 1.11.0"},{"location":"changelog/#version-1102","text":"2021-10-22 Thanks to @glureau and @goooler for contributing to this release. New: Switch AnnotationSpec.get() to use the arrayOf() syntax instead of [] . Fix: Don\u2019t wrap aliasing imports with long package names. Fix: Don\u2019t wrap type names inside line comments. Fix: Ignore Java\u2019s @Deprecated annotations on synthetic methods for annotations.","title":"Version 1.10.2"},{"location":"changelog/#version-1101","text":"2021-09-21 Thanks to @evant for contributing to this release. Fix: Correct generation of typealiases with type args in KSP interop. Fix: Add missing default TypeParameterResolver.EMPTY argument to fun KSTypeArgument.toTypeName in KSP interop.","title":"Version 1.10.1"},{"location":"changelog/#version-1100","text":"2021-09-20 Thanks to @martinbonnin , @idanakav , @goooler , and @anandwana001 for contributing to this release. New: Add a new KSP interop artifact. See docs for more details. New: Add a new JavaPoet interop artifact. See docs for more details. New: Allow copying a ParameterizedTypeName with new type arguments via new copy() overload. kotlinx-metadata artifacts have been consolidated to a single com.squareup:kotlinpoet-metadata maven artifact. The previous kotlinpoet-metadata-* subartifacts are no longer published. New: TypeNameAliasTag has been moved to KotlinPoet\u2019s main artifact under TypeAliasTag , for reuse with KSP interop. ImmutableKm* classes have been removed. They were deemed to be a needless abstraction over the base kotlinx-metadata Km types. All usages of these should be substituted with their non-immutable base types. Fix: Fix self-referencing type variables in metadata parsing. Fix: Use delicate APIs rather than noisy logging ones when converting annotation mirrors in AnnotationSpec.get . Fix: Update error message when metadata cannot be read to a more actionable one. Fix: Avoid escaping already escaped strings. Add docs about kotlin-reflect usage. Avoid using kotlin-reflect for looking up Unit types where possible. Test all the way up to JDK 17. Update Kotlin to 1.5.31.","title":"Version 1.10.0"},{"location":"changelog/#version-190","text":"2021-06-22 New: Kotlin 1.5.10. New: Previously deprecated API to interop with Java reflection and Mirror API have been un-deprecated and marked with @DelicateKotlinPoetApi annotation. New: CodeBlock.Builder.withIndent helper function. New: Allow changing initializers and default values in ParameterSpec.Builder and PropertySpec.Builder after they were set. New: MemberName.isExtension property that instructs KotlinPoet to always import the member, even if conflicting declarations are present in the same scope. Fix: Escape member names that only contain underscores. Fix: Always emit an empty primary constructor if it was set via TypeSpec.primaryConstructor .","title":"Version 1.9.0"},{"location":"changelog/#version-180","text":"2021-03-29 New: Kotlin 1.4.31. New: Add KModifier.VALUE to support value class declarations. New: Allow using a custom ClassLoader with ReflectiveClassInspector . New: Update to kotlinx-metadata 0.2.0. Fix: Ensure ImmutableKmProperty.toMutable() copies fieldSignature . Fix: Prevent name clashes between an imported MemberName and a member in current scope. Fix: Prevent name clashes between a type and a supertype with the same name. Fix: Don\u2019t generate empty body for expect and external functions. Fix: Don\u2019t allow expect or external classes to initialize supertypes. Fix: Disallow delegate constructor calls in external classes. Fix: Allow non-public primary constructors inside inline/value classes. Fix: Allow init blocks inside inline/value classes. Fix: Omit redundant abstract modifiers on members inside interfaces","title":"Version 1.8.0"},{"location":"changelog/#version-172","text":"2020-10-20 New: Detect expression bodies with return\u00b7 and throw\u00b7 prefixes. Fix: Omit visibility modifiers on custom accessors.","title":"Version 1.7.2"},{"location":"changelog/#version-171","text":"2020-10-15 Fix: 1.7.0 was published using JDK 11 which set \"org.gradle.jvm.version\" to \"11\" in Gradle metadata, making it impossible to use the library on earlier Java versions (see #999 ). 1.7.1 is published with JDK 8, which fixes the problem.","title":"Version 1.7.1"},{"location":"changelog/#version-170","text":"2020-10-14 New: Kotlin 1.4.10. New: Generated code is now compatible with the explicit API mode by default. New: Escape soft and modifier keywords, in addition to hard keywords. New: Improve enum constants generation for cleaner diffs. New: Disallow setters on immutable properties. New: Ensure trailing new lines in expression bodies. New: Ensure trailing new lines after parameterless custom setters. Fix: Don\u2019t auto-convert properties with custom accessors to primary constructor properties. Fix: Don\u2019t allow parameterless setters with body. Fix: Prevent auto-wrapping spaces inside escaped keywords.","title":"Version 1.7.0"},{"location":"changelog/#version-160","text":"2020-05-28 New: Deprecate Mirror API integrations. Mirror API integrations, such as TypeElement.asClassName() and FunSpec.overriding(ExecutableElement) , are being deprecated in this release. These KotlinPoet APIs are most often used in annotation processors. Since kapt runs annotation processors over stubs, which are Java files, a lot of the Kotlin-specific information gets lost in translation and cannot be accessed by KotlinPoet through the Mirror API integrations. Examples include: Alias types, such as kotlin.String , get converted to their JVM representations, such as java.lang.String . Type nullability information is not accessible. suspend functions are seen as simple functions with an additional Continuation parameter. The correct solution is to switch to KotlinPoet-metadata or KotlinPoet-metadata-specs API, which fetches Kotlin-specific information from the @Metadata annotation and produces correct KotlinPoet Specs. We may explore adding new metadata-based alternatives to the deprecated APIs in the future. New: Kotlin 1.3.72. New: Improve MemberName to support operator overloading. New: Support generics in AnnotationSpec . New: Add support for functional interfaces. New: Make more FunSpec.Builder members public for easier mutation. Fix: Properly propagate implicit type and function modifiers in nested declarations. Fix: Properly escape type names containing $ character. Fix: Don\u2019t emit LambdaTypeName annotations twice. Fix: Preserve tags in TypeName.copy() .","title":"Version 1.6.0"},{"location":"changelog/#version-150","text":"2020-01-09 KotlinPoet now targets JDK8, which means that executing a build that includes KotlinPoet as a dependency on a machine with an older version of JDK installed won\u2019t work. This has no effect on the code that KotlinPoet produces : the code can still be compiled against JDK6, as long as it doesn\u2019t use any features that were introduced in newer releases. New: Kotlin 1.3.61. New: Add support for processing FileFacades in KotlinPoet-metadata. New: Add support for inner nested and companion objects on annotation classes. New: Improve error messages for mismatched open/close statement characters. New: Tag AnnotationSpec s with the annotation mirror when available. New: Include annotations on enum entries when creating TypeSpec s from metadata. Fix: Fix metadata parsing for types. Fix: Allow file names that are Kotlin keywords. Fix: Properly escape type alias names with backticks. Fix: Allow creating TypeSpec s with names that can be escaped with backticks. Fix: Properly escape enum constant names with backticks. Fix: Maintain proper ordering of properties and initializers when emitting a TypeSpec . Note : with this change, any properties declared after any initializer blocks will not be added to the primary constructor and will instead be emitted inside the TypeSpec body. Fix: Don\u2019t emit a leading new line if type KDoc is empty but parameter KDocs are present. Fix: Ensure KotlinPoet-metadata resolves package names properly. ## Version 1.4.4 2019-11-16 Fix: Support reified inline types in KotlinPoet-metadata.","title":"Version 1.5.0"},{"location":"changelog/#version-143","text":"2019-10-30 Fix: Don\u2019t emit stubs for abstract functions in KotlinPoet-metadata.","title":"Version 1.4.3"},{"location":"changelog/#version-142","text":"2019-10-28 Fix: Properly handle abstract elements in KotlinPoet-metadata. Fix: Properly handle typealiases in KotlinPoet-metadata. Fix: Properly render % symbols at the end of KDocs.","title":"Version 1.4.2"},{"location":"changelog/#version-141","text":"2019-10-18 New: Add annotations support to TypeAliasSpec . New: Read type annotations from Kotlin Metadata . New: Introduce ImmutableKmDeclarationContainer . Fix: Use full package name for shading auto-common . Fix: Support reading self-type variables (e.g. Asset<A : Asset<A>> ) from Kotlin Metadata .","title":"Version 1.4.1"},{"location":"changelog/#version-140","text":"2019-09-24 New: This release introduces the new KotlinPoet-metadata API that makes it easy to introspect Kotlin types and build KotlinPoet Specs based on that data. The strategy for type introspection is driven by ClassInspector , which is a basic interface for looking up JVM information about a given Class. This optionally is used by the toTypeSpec() / toFileSpec() APIs in kotlinpoet-metadata-specs artifact to inform about Classes with information that isn\u2019t present in metadata (overrides, JVM modifiers, etc). There are two batteries-included implementations available in ReflectiveClassInspector (for reflection) and ElementsClassInspector (for the javax Elements API in annotation processing). These implementations are available through their respective kotlinpoet-classinspector-* artifacts. For more information refer to the KotlinPoet-metadata-specs README . At the time of this release the API is in experimental mode and has to be opted into via the KotlinPoetMetadataPreview annotation. New: Kotlin 1.3.50. New: A new constructor to simplify creation of ParameterSpec instances. New: New ClassName constructors. New: TypeName and subclasses can now store tags. New: Optional parameters added to toBuilder() methods of most Specs. New: List overrides for Spec methods that accept vararg s. New: CodeBlock.Builder.clear() helper method. New: FunSpec.Builder.clearBody() helper method. Fix: Properly escape enum constant names. Fix: Ensure trailing newlines in KDoc and function bodies. Fix: TypeVariableName s with empty bounds will now default to Any? . Fix: Don\u2019t emit parens for primary constructors. Fix: ClassName s with empty simple names are not allowed anymore. Fix: Throw if names contain illegal characters that can\u2019t be escaped with backticks.","title":"Version 1.4.0"},{"location":"changelog/#version-130","text":"2019-05-30 New: Don\u2019t inline annotations in the primary constructor. New: Force new lines when emitting primary constructors. New: Support using MemberNames as arguments to %N. New: Add more ClassName constants: ClassName.STRING, ClassName.LIST, etc. New: Add ClassName.constructorReference() and MemberName.reference(). New: Make %N accept MemberNames. New: Escape spaces in import aliases. New: Escape spaces in ClassNames. New: Escape spaces in MemberNames. New: Escape imports containing spaces. New: Escape package name containing spaces. New: Use 2-space indents. New: Only indent one level on annotation values. Fix: Pass only unique originating elements to Filer. Fix: Fix bug with MemberNames in same package nested inside a class.","title":"Version 1.3.0"},{"location":"changelog/#version-120","text":"2019-03-28 New: Add writeTo(Filer) and originating element API. New: Make *Spec types taggable. New: Make FunSpec.Builder#addCode take vararg Any?. Fix: Import members from default package. Fix: Add non-wrapping spaces in control flow creation methods. Fix: Named \u201cvalue\u201d argument being omitted in annotation array types.","title":"Version 1.2.0"},{"location":"changelog/#version-110","text":"2019-02-28 New: Kotlin 1.3.21. New: Support referencing members using %M and MemberName type. New: Add extensions for getting a MemberName from a ClassName , KClass and Class . New: Allow passing CodeBlock s as arguments to %P . New: Allow interface delegation for objects. Fix: Don\u2019t emit visible whitespace in toString() . Fix: Prevent line wrapping in weird places inside function signature. Fix: No line wrapping between val and property name. Fix: Allow passing line prefix into LineWrapper to enable proper line wrapping in KDoc. Fix: Add newline for TypeSpec Kdoc with no tags. Fix: Add newline for remaining Specs. Fix: Fix kdoc formatting for property getter/setters. Fix: Don\u2019t wrap single line comments inside FunSpec . Fix: Add non-wrapping package name. Fix: Remove n^2 algorithm in CodeWriter.resolve() by precomputing all of the nested simple names of a TypeSpec . Fix: Fix edge case with empty enum classes. Fix: Fix Nullable Type Parameter handling in KType.asTypeName() . Fix: Fix incorrect long comment wrapping in FileSpec . Fix: Attach primary constructor param/property KDoc to the element vs emitting it inside the type header.","title":"Version 1.1.0"},{"location":"changelog/#version-101","text":"2019-01-02 New: Allow enums without constants. New: Improved formatting of TypeSpec KDoc. New: Support @property and @param KDoc tags in TypeSpec. Fix: Use pre-formatted strings for arguments to %P.","title":"Version 1.0.1"},{"location":"changelog/#version-100","text":"2018-12-10 New: Kotlin 1.3.11. Fix: Prevent wrapping in import statements.","title":"Version 1.0.0"},{"location":"changelog/#version-100-rc3","text":"2018-11-28 New: Kotlin 1.3.10. New: Add %P placeholder for string templates. New: Add support for receiver kdoc. New: Avoid emitting Unit as return type. New: Add support for empty setters. New: Add checks for inline classes. New: Escape property and variable names if keywords. New: Replace %> , %< , %[ , %] placeholders with \u21e5 , \u21e4 , \u00ab , \u00bb . New: Replace %W with space, and add \u00b7 as a non-breaking space. New: Change TypeName to sealed class. New: Documentation improvements. New: Replace TypeName modifier methods with copy() . New: Rename members of WildcardTypeName to match with the producer/consumer generics model. New: Rename TypeName.nullable into TypeName.isNullable . New: Rename LambdaTypeName.suspending into LambdaTypeName.isSuspending . New: Rename TypeVariableName.reified into TypeVariableName.isReified . Fix: Emit star-projection only for types with Any? upper bound. Fix: Fold property with escaped name.","title":"Version 1.0.0-RC3"},{"location":"changelog/#version-100-rc2","text":"2018-10-22 New: Kotlin 1.2.71. New: README improvements. New: Allow opening braces and params in beginControlFlow() . New: Add KDoc to ParameterSpec , collapse into parent KDoc. New: Support TypeVariable s in PropertySpec . New: Add parens for annotated types in LambdaTypeName . New: Improve error messaging and documentation for inline properties. New: Allow sealed classes to declare abstract properties. New: Added buildCodeBlock() helper function. New: Allow using CodeBlock s with statements as property initializers and default parameter values. New: Rename NameAllocator.clone() into `NameAllocator.copy(). New: Rename TypeName.asNonNullable() to TypeName.asNonNull() . New: Remove PropertySpec.varBuilder() (use mutable() instead). New: Allow importing top-level members in default package. New: Add overloads to add KDoc to return type. Fix: Distinguishing IntArray and Array<Int> when creating TypeName . Fix: Use TypeName instead of ClassName as parameter type of plusParameter() . Fix: Keep type-parameter variance when constructing TypeName from KType . Fix: Don\u2019t validate modifiers when merging properties with primary constructor parameters. Fix: Escape $ characters in formatted strings. Fix: FileSpec.Builder blank package and subfolder fix. Fix: Append new line at end of parameter KDoc. Fix: Add parameter KDoc in toBuilder() .","title":"Version 1.0.0-RC2"},{"location":"changelog/#version-100-rc1","text":"2018-07-16 New: Escape keywords in imports and canonical class names. New: Improve external support. New: Extensions for KType and KTypeParameter . New: Add builder methods to simplify adding common kotlin.jvm annotations. New: Enums are able to have companion objects. New: Add missing primaryConstructor & companionObject to TypeSpec#toBuilder() . New: Make subtype checking vals inside Kind public. New: Escape (class/property/function/variable) names automatically if they contain space, hyphen, or other symbols. New: Improve ParameterizedTypeName API. New: Add WildcardTypeName.STAR constant. New: Expose mutable builder properties and move their validations to build-time. Fix: Use regular indents for parameter lists. Fix: Inline annotations on properties defined in primary constructor. Fix: Use Any? as the default type variable bounds. Fix: Fix importing annotated TypeName . Fix: If any primary constructor property has KDoc, put properties on new lines. Fix: Properly emit where block in type signature. Fix: Avoid type name collisions in primary constructor. Fix: Remove implicit TypeVariable bound when more bounds are added. Fix: Combine annotations and modifiers from constructor params and properties. Fix: Replace delegate constructor args along with the constructor.","title":"Version 1.0.0-RC1"},{"location":"changelog/#version-070","text":"2018-02-16 New: Increase indent to 4 spaces. New: Delegate super interfaces as constructor parameters. New: Support PropertySpec s as CodeBlock literals. New: Support KDoc for TypeAliasSpec . New: Allow for adding an initializer block inside a companion object. New: Escape name in ParameterSpec which is also a keyword. New: Escape names in statements. New: Set com.squareup.kotlinpoet as automatic module name. New: Support suspending lambda types. New: Support named LambdaTypeName parameters. New: Support dynamic type. New: Disallow wildcard imports. New: Depend on Kotlin 1.2.21. Fix: Correct handling of super-classes/interfaces on anonymous classes. Fix: Fix boundary filtering to Any? . Fix: Wrap long property initializers. Fix: Fix formatting and indentation of parameter lists.","title":"Version 0.7.0"},{"location":"changelog/#version-060","text":"2017-11-03 New: Support lambda extensions. New: Support renames in imports like import bar.Bar as bBar . New: Support extension and inline properties. New: Support reified types. New: Expose enclosed types inside LambdaTypeName . New: Depend on Kotlin Kotlin 1.1.51. New: Improved API and formatting of annotations. New: Improved multiplatform support. Fix: Escape function and package names if they are a Kotlin keyword. Fix: Properly format WildcardTypeName\u2019s class declaration.","title":"Version 0.6.0"},{"location":"changelog/#version-050","text":"2017-09-13 New: Rename addFun() to addFunction() . New: Rename KotlinFile to FileSpec . New: Rename KotlinFile.addFileAnnotation() to addAnnotation() . New: Rename KotlinFile.addFileComment() to addComment() . New: Support cross-platform code, including HEADER and IMPL modifiers. New: Support type variables for type aliases. New: Support constructor delegation. New: Support named companion objects. New: Depend on Kotlin 1.1.4-3. Fix: Format one parameter per line when there are more than two parameters. Fix: Don\u2019t emit braces when the constructor body is empty. Fix: Do not invoke superclass constructor when no primary constructor. Fix: Enforce the right modifiers on functions.","title":"Version 0.5.0"},{"location":"changelog/#version-040","text":"2017-08-08 New: Change KotlinPoet\u2019s extensions like asClassName() to be top-level functions. New: Add declaration-site variance support. New: Improve handling of single expression bodies. New: Support file annotations. New: Support imports from the top-level file. New: Accept superclass constructor parameters. New: Support primary constructors using the constructor keyword. Fix: Don\u2019t emit setter parameter types. Fix: Support Kotlin keywords in NameAllocator . Fix: Emit the right default parameters for primary constructors. Fix: Format annotations properly when used as parameters. Fix: Recognize imports when emitting nullable types. Fix: Call through to the superclass constructor when superclass has a no-args constructor. Fix: Omit class braces if all properties are declared in primary constructor. Fix: Don\u2019t emit empty class bodies. Fix: Emit the right syntax for declaring multiple generic type constraints. Fix: Support properties on objects, companions and interfaces. Fix: Use AnnotationSpec for throws.","title":"Version 0.4.0"},{"location":"changelog/#version-030","text":"2017-06-11 New: Objects and companion objects. New: TypeAliasSpec to create type aliases. New: LambdaTypeName to create lambda types. New: Collapse property declarations into constructor params. New: Extension and invoke functions for creating type names: Runnable::class.asClassName() . New: Basic support for expression bodies. New: Basic support for custom accessors. New: Remove Filer writing and originating elements concept. These stem from javac annotation processors. Fix: Generate valid annotation classes. Fix: Use KModifier for varargs. Fix: Use ParameterizedTypeName for array types. Fix: Extract Kotlin name from KClass instead of Java name. Fix: Emit valid class literals: Double::class instead of Double.class . Fix: Emit modifiers in the expected order. Fix: Emit the correct syntax for enum classes and overridden members.","title":"Version 0.3.0"},{"location":"changelog/#version-020","text":"2017-05-21 New: Flip API signatures to be (name, type) instead of (type, name). New: Support for nullable types. New: Support delegated properties. New: Extension functions. New: Support top-level properties. Fix: Inheritance should use : instead of extends and implements . Fix: Make initializerBlock emit init {} .","title":"Version 0.2.0"},{"location":"changelog/#version-010","text":"2017-05-16 Initial public release.","title":"Version 0.1.0"},{"location":"contributing/","text":"Contributing \u00b6 If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running ./gradlew clean build . Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"contributing/#contributing","text":"If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running ./gradlew clean build . Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"interop-javapoet/","text":"JavaPoet Extensions for KotlinPoet \u00b6 interop:javapoet is an interop API for converting JavaPoet types to KotlinPoet types. This is particularly useful for projects that support code gen in multiple languages and want to easily be able to jump between. Note that this API is currently in preview and subject to API changes. Usage of them requires opting in to the @KotlinPoetJavaPoetPreview annotation. Examples \u00b6 Typealiases for common conflicting type names // Points to com.squareup.kotlinpoet.TypeName KTypeName // Points to com.squareup.javapoet.TypeName JTypeName Convert between a JTypeName and KTypeName Most usages of these can run through the toKTypeName() and toJTypeName() extensions. val jType = JTypeName . get ( \"com.example\" , \"Taco\" ) // Returns a KotlinPoet `ClassName` of value `com.example.Taco` val kType = jType . toKTypeName () // Returns a JavaPoet `ClassName` of value `com.example.Taco` val jType2 = kType . toJTypeName () Intrinsics \u00b6 Kotlin supports a number of intrinsic types that live in the kotlin package, such as primitives, List , String , IntArray , etc. Where possible, interop will best-effort attempt to convert to the idiomatic Kotlin type when converting from the Java type. Lossy Conversions \u00b6 Kotlin has more expressive types in some regards. These cannot be simply expressed in JavaPoet and are subject to lossy conversions. Examples include: Nullability Nullable types in Kotlin will appear as normal types in JavaPoet. Collection mutability Immutable Kotlin collections will convert to their standard (mutable) Java analogs. Java collections will convert to immutable Kotlin analogs, erring on the side of safety in generated public APIs Unsigned types","title":"Interop - JavaPoet"},{"location":"interop-javapoet/#javapoet-extensions-for-kotlinpoet","text":"interop:javapoet is an interop API for converting JavaPoet types to KotlinPoet types. This is particularly useful for projects that support code gen in multiple languages and want to easily be able to jump between. Note that this API is currently in preview and subject to API changes. Usage of them requires opting in to the @KotlinPoetJavaPoetPreview annotation.","title":"JavaPoet Extensions for KotlinPoet"},{"location":"interop-javapoet/#examples","text":"Typealiases for common conflicting type names // Points to com.squareup.kotlinpoet.TypeName KTypeName // Points to com.squareup.javapoet.TypeName JTypeName Convert between a JTypeName and KTypeName Most usages of these can run through the toKTypeName() and toJTypeName() extensions. val jType = JTypeName . get ( \"com.example\" , \"Taco\" ) // Returns a KotlinPoet `ClassName` of value `com.example.Taco` val kType = jType . toKTypeName () // Returns a JavaPoet `ClassName` of value `com.example.Taco` val jType2 = kType . toJTypeName ()","title":"Examples"},{"location":"interop-javapoet/#intrinsics","text":"Kotlin supports a number of intrinsic types that live in the kotlin package, such as primitives, List , String , IntArray , etc. Where possible, interop will best-effort attempt to convert to the idiomatic Kotlin type when converting from the Java type.","title":"Intrinsics"},{"location":"interop-javapoet/#lossy-conversions","text":"Kotlin has more expressive types in some regards. These cannot be simply expressed in JavaPoet and are subject to lossy conversions. Examples include: Nullability Nullable types in Kotlin will appear as normal types in JavaPoet. Collection mutability Immutable Kotlin collections will convert to their standard (mutable) Java analogs. Java collections will convert to immutable Kotlin analogs, erring on the side of safety in generated public APIs Unsigned types","title":"Lossy Conversions"},{"location":"interop-kotlinx-metadata/","text":"KotlinPoet-metadata \u00b6 interop:kotlinx-metadata is an API for working with Kotlin @Metadata annotations. Its API sits atop kotlinx-metadata , offering extensions for its types + JVM metadata information. This can be used to read Kotlin language semantics off of Class or TypeElement @Metadata annotations. Example \u00b6 data class Taco ( val seasoning : String , val soft : Boolean ) { fun prepare () { } } val kmClass = Taco :: class . toKmClass () // Now you can access misc information about Taco from a Kotlin lens println ( kmClass . name ) kmClass . properties . forEach { println ( it . name ) } kmClass . functions . forEach { println ( it . name ) } Flags \u00b6 There are a number of boolean flags available to types as well under Flags.kt . These read the underlying kotlinx-metadata Flags property. Using the Taco example above, we can glean certain information: println ( \"Is class? ${ kmClass . isClass } \" ) println ( \"Is data class? ${ kmClass . isData } \" ) Interop with KotlinPoet \u00b6 interop:kotlinx-metadata offers an API for converting core kotlinx-metadata Km types to KotlinPoet source representations of their APIs. This includes full type resolution, signatures, enclosed elements, and general stub source representations of the underlying API. Example \u00b6 data class Taco ( val seasoning : String , val soft : Boolean ) { fun prepare () { } } val typeSpec = Taco :: class . toTypeSpec () // Or FileSpec val fileSpec = Taco :: class . toFileSpec () Source representation \u00b6 The generated representations are a best effort representation of the underlying source code. This means that synthetic elements will be excluded from generation. Kotlin-specific language features like lambdas or delegation will be coerced to their idiomatic source form. To aid with this, toTypeSpec() and toFileSpec() accept optional ClassInspector instances to assist in parsing/understanding the underlying JVM code. This is important for things like annotations, companion objects, certain JVM modifiers, overrides, and more. While it is optional, represented sources can be incomplete without this information available. Reflective and javax Elements implementations are available under the com.squareup.kotlinpoet.metadata.classinspectors package. Generated sources are solely stub implementations, meaning implementation details of elements like functions, property getters, and delegated properties are simply stubbed with TODO() placeholders. Known limitations \u00b6 Only KotlinClassMetadata.Class and KotlinClassMetadata.FileFacade are supported for now. No support for SyntheticClass , MultiFileClassFacade , or MultiFileClassPart @JvmOverloads annotations are only supported with ElementsClassInspector and not reflection. Non-const literal values are only supported with ElementsClassInspector and not reflection. ClassInspector data sourced from synthetic constructs are only supported with ReflectiveClassInspector and not elements. This is because the javax Elements API does not model synthetic constructs. This can yield some missing information, like static companion object properties or property: site target annotations. Annotations annotated with AnnotationRetention.SOURCE are not parsable in reflection nor javax elements.","title":"Interop - kotlinx-metadata"},{"location":"interop-kotlinx-metadata/#kotlinpoet-metadata","text":"interop:kotlinx-metadata is an API for working with Kotlin @Metadata annotations. Its API sits atop kotlinx-metadata , offering extensions for its types + JVM metadata information. This can be used to read Kotlin language semantics off of Class or TypeElement @Metadata annotations.","title":"KotlinPoet-metadata"},{"location":"interop-kotlinx-metadata/#example","text":"data class Taco ( val seasoning : String , val soft : Boolean ) { fun prepare () { } } val kmClass = Taco :: class . toKmClass () // Now you can access misc information about Taco from a Kotlin lens println ( kmClass . name ) kmClass . properties . forEach { println ( it . name ) } kmClass . functions . forEach { println ( it . name ) }","title":"Example"},{"location":"interop-kotlinx-metadata/#flags","text":"There are a number of boolean flags available to types as well under Flags.kt . These read the underlying kotlinx-metadata Flags property. Using the Taco example above, we can glean certain information: println ( \"Is class? ${ kmClass . isClass } \" ) println ( \"Is data class? ${ kmClass . isData } \" )","title":"Flags"},{"location":"interop-kotlinx-metadata/#interop-with-kotlinpoet","text":"interop:kotlinx-metadata offers an API for converting core kotlinx-metadata Km types to KotlinPoet source representations of their APIs. This includes full type resolution, signatures, enclosed elements, and general stub source representations of the underlying API.","title":"Interop with KotlinPoet"},{"location":"interop-kotlinx-metadata/#example_1","text":"data class Taco ( val seasoning : String , val soft : Boolean ) { fun prepare () { } } val typeSpec = Taco :: class . toTypeSpec () // Or FileSpec val fileSpec = Taco :: class . toFileSpec ()","title":"Example"},{"location":"interop-kotlinx-metadata/#source-representation","text":"The generated representations are a best effort representation of the underlying source code. This means that synthetic elements will be excluded from generation. Kotlin-specific language features like lambdas or delegation will be coerced to their idiomatic source form. To aid with this, toTypeSpec() and toFileSpec() accept optional ClassInspector instances to assist in parsing/understanding the underlying JVM code. This is important for things like annotations, companion objects, certain JVM modifiers, overrides, and more. While it is optional, represented sources can be incomplete without this information available. Reflective and javax Elements implementations are available under the com.squareup.kotlinpoet.metadata.classinspectors package. Generated sources are solely stub implementations, meaning implementation details of elements like functions, property getters, and delegated properties are simply stubbed with TODO() placeholders.","title":"Source representation"},{"location":"interop-kotlinx-metadata/#known-limitations","text":"Only KotlinClassMetadata.Class and KotlinClassMetadata.FileFacade are supported for now. No support for SyntheticClass , MultiFileClassFacade , or MultiFileClassPart @JvmOverloads annotations are only supported with ElementsClassInspector and not reflection. Non-const literal values are only supported with ElementsClassInspector and not reflection. ClassInspector data sourced from synthetic constructs are only supported with ReflectiveClassInspector and not elements. This is because the javax Elements API does not model synthetic constructs. This can yield some missing information, like static companion object properties or property: site target annotations. Annotations annotated with AnnotationRetention.SOURCE are not parsable in reflection nor javax elements.","title":"Known limitations"},{"location":"interop-ksp/","text":"KSP Extensions for KotlinPoet \u00b6 interop:ksp is an interop API for converting Kotlin Symbol Processing (KSP) types to KotlinPoet types and writing to KSP CodeGenerator . Note that this API is currently in preview and subject to API changes. Usage of it requires opting in to the @KotlinPoetKspPreview annotation. dependencies { implementation ( \"com.squareup:kotlinpoet-ksp:<version>\" ) } Examples \u00b6 Examples are based on reading the following property as a KSProperty : class Taco { internal inline val seasoning : String get () = \"spicy\" } Convert a KSType to a TypeName // returns a `ClassName` of value `kotlin.String` seasoningKsProperty . type . toTypeName () Convert a Modifier to a KModifier // returns `[KModifier.INLINE]` seasoningKsProperty . modifiers . mapNotNull { it . toKModifier () } Convert a Visibility to a KModifier // returns `KModifier.INTERNAL` seasoningKsProperty . getVisibility (). toKModifier () Write to CodeGenerator To write a FileSpec to a KSP CodeGenerator , simply call the FileSpec.writeTo(CodeGenerator, ...) extension function. fileSpec . writeTo ( codeGenerator ) Type Parameters \u00b6 Type parameters can be declared on classes, functions, and typealiases. These parameters are then available to all of its enclosed elements. In order for these elements to resolve these in KSP, you must be able to reference these type parameters by their index . In kotlinpoet-ksp this is orchestrated by the TypeParameterResolver API, which can be passed into most toTypeName() (or similar) functions to give them access to enclosing type parameters that they may reference. The canonical way to create an instance of this is to call toTypeParameterResolver() on a List<KSTypeParameter> . Consider the following class and function abstract class Taco < T > { abstract val seasoning : T } To properly resolve the type of seasoning , we need to pass the class TypeParameterResolver to toTypeName() so that it can properly resolve it. val classTypeParams = ksClassDeclaration . typeParameters . toTypeParameterResolver () // returns `T` val seasoningType = seasoningKsProperty . type . toTypeName ( classTypeParams ) TypeParameterResolver is also composable to allow for multi-level nesting. toTypeParameterResolver() has an optional parent parameter to provide a parent instance. Consider our previous example again, but this time with a function that defines its own type parameters. class Taco < T > { fun < E > getShellOfType ( param1 : E , param2 : T ) { } } To resolve its parameters, we need to create a TypeParameterResolver from the function\u2019s typeParameters and compose it with the enclosing class\u2019s type parameters as a parent . val classTypeParams = ksClassDeclaration . typeParameters . toTypeParameterResolver () val functionTypeParams = ksFunction . typeParameters . toTypeParameterResolver ( parent = classTypeParams ) // returns `[E, T]` val seasoningType = ksFunction . parameterTypes . map { it . toTypeName ( functionTypeParams ) } Incremental Processing \u00b6 KSP supports incremental processing as long as symbol processors properly indicate originating files in generated new files and whether or not they are aggregating . kotlinpoet-ksp supports this via OriginatingKSFiles , which is a simple API that sits atop KotlinPoet\u2019s Taggable API. To use this, simply add relevant originating files to any TypeSpec , TypeAliasSpec , PropertySpec , or FunSpec builders. val functionBuilder = FunSpec . builder ( \"sayHello\" ) . addOriginatingKSFile ( sourceKsFile ) . build () Like KotlinPoet\u2019s originating elements support for javac annotation processors, calling the FileSpec.writeTo(CodeGenerator, ...) function will automatically collect and de-dupe these originating KSFile references and automatically assemble them in the underlying Dependencies for KSP\u2019s reference. Optionally you can define your own collection of files and pass them to the writeTo function, but usually you don\u2019t need to do this manually. Lastly - FileSpec.writeTo(CodeGenerator, ...) also requires you to specify if your processor is aggregating or not via required parameter by the same name. TypeAlias Handling \u00b6 For typealias types, KSP interop will store a TypeAliasTag in the TypeName \u2018s tags with a reference to the abbreviated type. This can be useful for APIs that want to resolve all un-aliased types.","title":"Interop - KSP"},{"location":"interop-ksp/#ksp-extensions-for-kotlinpoet","text":"interop:ksp is an interop API for converting Kotlin Symbol Processing (KSP) types to KotlinPoet types and writing to KSP CodeGenerator . Note that this API is currently in preview and subject to API changes. Usage of it requires opting in to the @KotlinPoetKspPreview annotation. dependencies { implementation ( \"com.squareup:kotlinpoet-ksp:<version>\" ) }","title":"KSP Extensions for KotlinPoet"},{"location":"interop-ksp/#examples","text":"Examples are based on reading the following property as a KSProperty : class Taco { internal inline val seasoning : String get () = \"spicy\" } Convert a KSType to a TypeName // returns a `ClassName` of value `kotlin.String` seasoningKsProperty . type . toTypeName () Convert a Modifier to a KModifier // returns `[KModifier.INLINE]` seasoningKsProperty . modifiers . mapNotNull { it . toKModifier () } Convert a Visibility to a KModifier // returns `KModifier.INTERNAL` seasoningKsProperty . getVisibility (). toKModifier () Write to CodeGenerator To write a FileSpec to a KSP CodeGenerator , simply call the FileSpec.writeTo(CodeGenerator, ...) extension function. fileSpec . writeTo ( codeGenerator )","title":"Examples"},{"location":"interop-ksp/#type-parameters","text":"Type parameters can be declared on classes, functions, and typealiases. These parameters are then available to all of its enclosed elements. In order for these elements to resolve these in KSP, you must be able to reference these type parameters by their index . In kotlinpoet-ksp this is orchestrated by the TypeParameterResolver API, which can be passed into most toTypeName() (or similar) functions to give them access to enclosing type parameters that they may reference. The canonical way to create an instance of this is to call toTypeParameterResolver() on a List<KSTypeParameter> . Consider the following class and function abstract class Taco < T > { abstract val seasoning : T } To properly resolve the type of seasoning , we need to pass the class TypeParameterResolver to toTypeName() so that it can properly resolve it. val classTypeParams = ksClassDeclaration . typeParameters . toTypeParameterResolver () // returns `T` val seasoningType = seasoningKsProperty . type . toTypeName ( classTypeParams ) TypeParameterResolver is also composable to allow for multi-level nesting. toTypeParameterResolver() has an optional parent parameter to provide a parent instance. Consider our previous example again, but this time with a function that defines its own type parameters. class Taco < T > { fun < E > getShellOfType ( param1 : E , param2 : T ) { } } To resolve its parameters, we need to create a TypeParameterResolver from the function\u2019s typeParameters and compose it with the enclosing class\u2019s type parameters as a parent . val classTypeParams = ksClassDeclaration . typeParameters . toTypeParameterResolver () val functionTypeParams = ksFunction . typeParameters . toTypeParameterResolver ( parent = classTypeParams ) // returns `[E, T]` val seasoningType = ksFunction . parameterTypes . map { it . toTypeName ( functionTypeParams ) }","title":"Type Parameters"},{"location":"interop-ksp/#incremental-processing","text":"KSP supports incremental processing as long as symbol processors properly indicate originating files in generated new files and whether or not they are aggregating . kotlinpoet-ksp supports this via OriginatingKSFiles , which is a simple API that sits atop KotlinPoet\u2019s Taggable API. To use this, simply add relevant originating files to any TypeSpec , TypeAliasSpec , PropertySpec , or FunSpec builders. val functionBuilder = FunSpec . builder ( \"sayHello\" ) . addOriginatingKSFile ( sourceKsFile ) . build () Like KotlinPoet\u2019s originating elements support for javac annotation processors, calling the FileSpec.writeTo(CodeGenerator, ...) function will automatically collect and de-dupe these originating KSFile references and automatically assemble them in the underlying Dependencies for KSP\u2019s reference. Optionally you can define your own collection of files and pass them to the writeTo function, but usually you don\u2019t need to do this manually. Lastly - FileSpec.writeTo(CodeGenerator, ...) also requires you to specify if your processor is aggregating or not via required parameter by the same name.","title":"Incremental Processing"},{"location":"interop-ksp/#typealias-handling","text":"For typealias types, KSP interop will store a TypeAliasTag in the TypeName \u2018s tags with a reference to the abbreviated type. This can be useful for APIs that want to resolve all un-aliased types.","title":"TypeAlias Handling"}]}